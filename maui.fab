This is Mau Independent Fabricator, a standalone literate
programming tool with wiki-like notation.

<< IDENT >>:
  Mau Independent Fabricator << VERSION >>

<< VERSION >>:
  3.2.1


== Parsing

* Parser's front-end.

For the parser, [[input]] will be an open [[IO]] instance.  For
parsing ease (most crucially, in order to support blank lines in
chunks and indented blocks), we'll wrap it into a
[[Vertical_Peeker]].  The parser will generate [[OpenStruct]]
instances for vertical elements extracted from the input, in
order, and feed them into [[Integrator]] that will take care of
establishing a proper document tree, collecting the chunks for
later tangling, and preparing the cross-references.

If [[suppress_indexing]] is true, new index entries won't be
generated.  If [[suppress_narrative]] is true, narrative nodes
won't be generated and code nodes will be 'invisible' -- they're
only cross-linked for tangling but not entered into the
[[presentation]] list of the output.  (These two flags are
useful to support invisible 'base' files that establish
definitions before the main file gets loaded.)  If
[[nesting_mode]] is not [[nil]], the rules that do not make
sense in the specified nesting mode -- either [[:blockquote]] or
[[:subplot]] -- are disabled during the parsing.

The [[filename]] and [[first_line]] parameters, if given, are
passed on to [[Vertical_Peeker#initialize]] and used for
location calculations.  This allows a part of a file to be
parsed using the main parsing mechanism but still reporting
errors accurately.

<< Other methods >>:
  def parse_fabric_file input, integrator,
      suppress_indexing: false,
      suppress_narrative: false,
      nesting_mode: nil,
      filename: nil,
      first_line: 1
    raise 'assertion failed' \
        unless [nil, :blockquote, :subplot].include?(
            nesting_mode)
    << Parse fabric from [[input]] to [[integrator]] >>
    return
  end


<< Parse fabric from [[input]] to [[integrator]] >>:

  vp = Fabricator::Vertical_Peeker.new input,
      filename: filename,
      first_line: first_line


. space-dash-space ambiguity
The Mau notation has an ambiguity: a line starting with
whitespace, dash, and whitespace can start an indented block but
it can also start a bulleted list's item.  In order to resolve
the ambiguity, we'll require that top-level bullet lists be
unindented, and indented bullet items can only appear if a
higher-level list has already been established.

  parser_state = OpenStruct.new(
      vertical_separation: nil,
          # the number of blank lines immediately preceding
          # the element currently being parsed
  )
  loop do
    << Pass and count blank lines >>
    break if vp.eof?
    << Handle explicit section break >>
    element_location = vp.location_ahead
    line = vp.peek_line
    << Vertical elements' parsing rules >>
    end
    integrator.integrate element,
        suppress_indexing: suppress_indexing,
        suppress_narrative: suppress_narrative
  end
  if nesting_mode.nil? then
    << Handle the end of fabric >>
  end


. "more than two consecutive blank lines" (warning)

<< Pass and count blank lines >>:
  parser_state.vertical_separation = 0
  while vp.peek_line == '' do
    if parser_state.vertical_separation == 2 then
      integrator.warn vp.location_ahead,
          "more than two consecutive blank lines"
    end
    parser_state.vertical_separation += 1
    vp.get_line
  end


<< Vertical elements' parsing rules >>:
  if line =~ /^\s+/ then
    if !integrator.in_list? or
        vp.peek_line !~ /^
            (?<margin> \s+ )
            - (?<separator> \s+ )
            /x then
      << Parse indented block >>
    else
      << Parse deep bullet >>
    end


What looks to us like an indented block may need to be upgraded
into a chunk by the integrator.  Our parser does not know
whether this is the case because it does not keep track of
diversions.  Since location data is needed for chunks, we'll
record it, even if it might not be useful for ordinary indented
blocks.

<< Parse indented block >>:
  body_location = vp.location_ahead
  element = vp.get_indented_lines_with_skip
  element.type = OL_BLOCK
  element.body_loc = element_location


. [[get_indented_lines_with_skip]]

<< in [[Vertical_Peeker]] >>:
  def get_indented_lines_with_skip
    indent = nil; lines = []
    while peek_line =~ /^\s+/ or
        (peek_line == '' and
         !lines.empty? and
         peek_line(1) =~ /^\s+/) do
      # If the line ahead is not indented but we passed the
      # test, then [[get_line]] will return [[""]] and [[$&]]
      # is the /following/ line's indentation.
      indent = $&.length if indent.nil? or $&.length < indent
      lines.push get_line
    end
    return nil if lines.empty?
    lines.each{|l| l[0 ... indent] = ''}
    return OpenStruct.new(lines: lines, indent: indent)
  end


<< Parse deep bullet >>:
  margin = $~['margin']
  lines = [$~['separator'] + $']
  vp.get_line
  while !vp.eof? and
      vp.peek_line.start_with? margin and
      vp.peek_line !~ /^\s*-\s/ do
    lines.push vp.get_line[margin.length .. -1]
  end
  element = OpenStruct.new(
    type: OL_ITEM,
    lines: lines,
    content: parse_markup(lines.map(&:strip).join ' '),
    indent: margin.length,
    loc: element_location)


A standard chunk header is by its own a divert.  However, if
it's followed by an indented block, it's a chunk.

<< Vertical elements' parsing rules >>:

  elsif nesting_mode != :blockquote and line =~ /^<<\s*
      (?: (?<root-type> \.file|\.script) \s+ )?
      (?<raw-name> [^\s].*?)
      (?: \s* \# (?<seq> \d+) )?
      \s*>>:$/x then
    name = canonicalise $~['raw-name']
    vp.get_line
    element = OpenStruct.new(
      type: OL_DIVERT,
      root_type: $~['root-type'],
      name: name,
      seq: $~['seq'] && $~['seq'].to_i,
      header_loc: element_location)

    body_location = vp.location_ahead
    body = vp.get_indented_lines_with_skip
    if body then
      element.type = OL_CHUNK
      element.lines = body.lines
      element.indent = body.indent
      element.body_loc = body_location
      element.initial = element.final = true
    end


. thematic break, parsing

Our thematic break notation is inspired by MarkDown.  The basic
detection criterion is three or more stars, dashes, or
underscores alone on a line.  Unlike MarkDown, we only recognise
this notation unindented.  Whitespace can be used between stars
or underscores but not dashes, for that might greate complex
ambiguities with other dash-based syntaxes, most importantly
bullets but also n-dashes and m-dashes.

  elsif line =~ /^---+$/ or line =~ /^(\*\s*){3,}$/ or
      line =~ /^(_\s*){3,}$/ then
    vp.get_line
    element = OpenStruct.new type: OL_THEMBREAK


Next, let's consider top-level bullets.

  elsif line =~ /^-\s/ then
    # We'll discard the leading dash but save the following
    # whitespace.
    lines = [vp.get_line[1 .. -1]]
    while !vp.eof? and
        vp.peek_line != '' and
        vp.peek_line !~ /^\s*-\s/ do
      lines.push vp.get_line
    end
    element = OpenStruct.new(
      type: OL_ITEM,
      lines: lines,
      content: parse_markup(lines.map(&:strip).join ' '),
      indent: 0,
      loc: element_location)


A line starting with a [[>]] character begins a blockquote.

  elsif line[0] == ?> then
    start_location = vp.location_ahead
    content = vp.parse_block ?>
    # Blockquotes are purely narrative nodes, so if narrative
    # processing is suppressed, there's no point in parsing
    # their content.
    unless suppress_narrative then
      # We'll initiate the blockquote by constructing a blank
      # [[OL_BLOCKQUOTE]] node and sending it to the integrator.
      integrator.integrate OpenStruct.new(
              type: OL_BLOCKQUOTE,
              elements: []),
          suppress_indexing: suppress_indexing
      parse_fabric_file StringIO.new(content), integrator,
          suppress_indexing: suppress_indexing,
          nesting_mode: :blockquote,
          filename: start_location.filename,
          first_line: start_location.line
      integrator.end_blockquote
    end
    next
        # since we have no [[element]] to be handled after the
        # massive [[if ...]] construct, we'll have to restart
        # the loop manually here


. [[parse_block]] (method of [[Vertical_Peeker]])

<< in [[Vertical_Peeker]] >>:
  def parse_block prefix
    lines = []
    while !eof? and peek_line[0] == prefix do
      lines.push get_line[1 .. -1]
    end

    indent = nil
    lines.each do |line|
      next if line.empty?
      line =~ /^\s*/
      if indent then
        indent = [indent, $&.length].min
      else
        indent = $&.length
      end
    end
    if indent and indent != 0 then
      lines = lines.map{|l| l[indent .. -1]}
    end

    return lines * "\n"
  end


A line starting with a [[|]] character begins a subplot.

<< Vertical elements' parsing rules >>:
  elsif nesting_mode != :blockquote and line[0] == ?| then
    start_location = vp.location_ahead
    content = vp.parse_block ?|

    integrator.integrate OpenStruct.new(
            type: OL_SUBPLOT,
            elements: []),
        suppress_narrative: suppress_narrative,
        suppress_indexing: suppress_indexing
    parse_fabric_file StringIO.new(content), integrator,
        suppress_indexing: suppress_indexing,
        nesting_mode: :subplot,
        filename: start_location.filename,
        first_line: start_location.line
    integrator.end_subplot
    next
        # since we have no [[element]] to be handled after the
        # massive [[if ...]] construct, we'll have to restart
        # the loop manually here


<< Vertical elements' parsing rules >>:


. [[OL_INDEX_ANCHOR]]

A line starting with a period and whitespace is an index
reference anchor.  This is a line-level, not paragraph-level,
notation so that multiple anchor lines can immediately follow
each other without the need for intervening whitespace.
Luckily, index keywords (or -phrases) are normally reasonably
short.

  elsif nesting_mode != :blockquote and line =~ /^\.\s+/ then
    name = $'
    element = OpenStruct.new(
        type: OL_INDEX_ANCHOR,
        name: name)
    vp.get_line


. [[OL_EXPLICIT_TOC]]
. [[.toc]] directive, parsing

A line consisting of the string [[.toc]] (recognised
case-insensitively) is the place for the table of contents.  It
is not recognised inside blockquotes or subplots.

  elsif nesting_mode.nil? and line.downcase == '.toc' then
    element = OpenStruct.new type: OL_EXPLICIT_TOC
    vp.get_line


Finally, a line starting with a non-whitespace character starts
an ordinary paragraph, a title, or a rubric.

  elsif line =~ /^[^\s]/ then
    lines = []
    while vp.peek_line =~ /^[^\s]/ and
        vp.peek_line !~ /^-\s/ do
      lines.push vp.get_line
    end
    mode_flags_to_suppress = 0
    << Rules for interpreting a paragraph-like element >>
    end
    element.lines = lines
    element.content =
        parse_markup(lines.map(&:strip).join(' '),
        mode_flags_to_suppress)


<< Rules for interpreting a paragraph-like element >>:

  if nesting_mode.nil? and lines[0] =~ /^(==+)(\s+)/ then
    lines[0] = $2 + $'
    element = OpenStruct.new(
      type: OL_TITLE,
      level: $1.length - 1,
      loc: element_location)
    mode_flags_to_suppress |= PF_LINK


  elsif nesting_mode.nil? and lines[0] =~ /^\*\s+/ then
    lines[0] = $'
    element = OpenStruct.new(
        type: OL_RUBRIC,
        loc: element_location)


  else
    element = OpenStruct.new(
        type: OL_PARAGRAPH,
        loc: element_location)


Now, let's go back to the main parsing loop.

Seeing two (or more) consecutive blank lines in front our
element triggers an explicit section break.

<< Handle explicit section break >>:
  if parser_state.vertical_separation >= 2 then
    if nesting_mode != :blockquote then
      integrator.force_section_break
    else
      # FIXME: generate a warning about ignoring the section
      # break because of blockquote mode
    end
  end


The integrator checks sections for emptiness (this would mean
that an explicitly delimited section contains only index
anchors), adds the [[[final]] tag to a diverted chunk chain's
last chunk, and checks whether a diversion actually applies to
any chunks when the chain ends.  Inside a fabric, this happens
by the appearance of certain types of elements -- chunks,
diversions, titles -- but when the fabric is over, we'll have to
make it explicit.

<< Handle the end of fabric >>:
  integrator.force_section_break
  integrator.clear_diversion


Once we have all the chunks, we can check that the root types of
all root chunks match each other.  It's not (usually) a serious
error, but the user might want to know.

  integrator.check_root_type_consistency


For this check, we iterate over chunk headers, so as not to
generate excessive warnings when the fault lies in a diversion.

. [[check_root_type_consistency]]
. "inconsistent root type" (warning)

<< in [[Integrator]] >>:
  def check_root_type_consistency
    @output.roots.each do |name|
      cbn_entry = @output.chunks_by_name[name]
      effective_root_type = cbn_entry.root_type
      cbn_entry.headers.each do |element|
        unless element.root_type == effective_root_type then
          warn element.header_loc,
              "inconsistent root type, assuming %s" %
                  effective_root_type
        end
      end
    end
    return
  end


* Vertical peekaboo.

The [[Vertical_Peeker]] class implements a line-level lookahead
on an [[IO]] instance.  We won't limit the lookahead, although
we'll only need two lines (when checking whether a blank line in
an indented block is followed by another indented line).

. [[Vertical_Peeker]]

<< in [[Fabricator]] >>:
  class Vertical_Peeker
    << in [[Vertical_Peeker]] >>
  end


<< in [[Vertical_Peeker]] >>:

  def initialize port,
      filename: nil,
      first_line: 1
    super()
    @port = port
    @filename =
        if filename then
          filename
        elsif @port.respond_to? :path then
          @filename = @port.path
        elsif @port == $stdin then
          @filename = '(stdin)'
        else
          @filename = '(unknown)'
        end
    @buffer = []
    @line_number = first_line
    @eof_seen = false
    return
  end


. [[peek_line]]

  def peek_line ahead = 0
    raise 'invalid argument' unless ahead >= 0
    until @buffer.length > ahead or @eof_seen do
      line = @port.gets
      if line then
        line.rstrip!
        @buffer.push line
      else
        @eof_seen = true
      end
    end
    return @buffer[ahead] # nil if past eof
  end


. [[get_line]] (method of [[Vertical_Peeker]])

  def get_line
    # ensure that if a line is available, it's in [[@buffer]]
    peek_line

    @line_number += 1 unless @buffer.empty?
    return @buffer.shift
  end


. [[eof?]] (method of [[Vertical_Peeker]])

  def eof?
    return peek_line.nil?
  end


. [[lineno_ahead]] (method of [[Vertical_Peeker]])

  def lineno_ahead
    return @line_number + (@line_consumed ? 1 : 0)
  end


. [[location_ahead]] (method of [[Vertical_Peeker]])

  def location_ahead
    return OpenStruct.new(
      filename: @filename, line: lineno_ahead)
  end


* Integration.

An [[Integrator]] builds an internal representation of a fabric
from the vertical elements extracted by a parser.

. [[Integrator]]

<< in [[Fabricator]] >>:
  class Integrator
    << in [[Integrator]] >>
  end


The root of the result, which will be a graph built out of
[[OpenStruct]]s, can be accessed by the method
[[Integrator#output]].

. [[output]] (accessor method of [[Integrator]])

<< in [[Integrator]] >>:
  attr_reader :output


Its top-level structure is evident from the initialisation
construct.

. [[@output]] (slot of [[Integrator]])

<< Initialise [[Integrator@output]] >>:
  @output = OpenStruct.new(
    << Fields of [[Integrator@output]] >>
  )


<< Fields of [[Integrator@output]] >>:

The /content/ of the fabric will be stored in the integrator
output under the key of [[presentation]].  In its immediate
form, it's a Ruby [[Array]] containing the [[OL_TITLE]],
[[OL_SECTION]], [[OL_SUBPLOT]], and [[OL_THEMBREAK]] nodes, in
order; the first three kinds of these can contain further,
lower-level, structure.

  presentation: [], # list of titles and sections


In order to simplify generating the table of content of the
fabric, we'll furthermore gather the [[OL_TITLE]] and
[[OL_RUBRIC]] nodes into the integrator's output under the key
of [[toc]].  It's a flat list; however, [[OL_TITLE]] nodes will
define a hierarchical structure by their [[level]] fields.

  toc: [], # list of titles and rubrics.


In order to simplify /tangling/ of the files defined in the
fabric, we'll collect all their chunks into the integrator's
output structure under the key of [[chunks_by_name]].  (See also
[[canonicalise]].)

  chunks_by_name: {},
      # canonical_name => OpenStruct
      #   root_type: String
      #   chunks: list of OL_CHUNK/OL_DIVERTED_CHUNK nodes
      #   headers: list of OL_CHUNK/OL_DIVERT records


Also, we'll collect the (canonicalised) names of the root
chunks.

  roots: [], # list of canonical names


Mau is a wiki engine, so in accordance with long-standing
custom, Maui strives to recover -- of course, not always very
well -- from almost all kinds of errors that it may detect
during processing a fabric object.  In order to help a human
diagnose and resolve such errors, it generates a /warning/ each
time it detects one, and we'll collect them into the
integrator's output structure.

  warnings: [],


. [[:manual]] (index reference type)
. [[:definition]] (index reference type)
. [[:transclusion]] (index reference type)

Last but not least, we'll collect /index reference entries/ of
three types ([[:manual]], [[:definition]], and
[[:transclusion]]), and arrange them for easy retrieval.

  index: {},
      # keyword => OpenStruct
      #   sort_key: string,
      #   canonical_representation: markup list,
      #   refs: [[number, reftype], ...],


The integrator has a number of other internal variables which
are only used while the fabric is being integrated.  In essence,
they hold a high-level state of the parser.  Let's initialise
them next:

<< in [[Integrator]] >>:

  def initialize first_section: 1
    super()
    << Initialise [[Integrator@output]] >>
    @cursec = nil # The current section if started
    @first_section_number = first_section
    @section_count = 0 # The number of last section
    # We'll issue all chunks 'ord' numbers in the order they
    # appear, so that we can use these as a fall-back sort key
    # when sorting chunks by optional sequence numbers.
    # (Recall that Ruby's [[sort]] is not stable.)
    # Intuitively, we could just use section numbers, but this
    # fails when we'll preload a 'base' fabric before the main
    # fabric without assigning the base fabric any section
    # numbers.
    @chunk_ord_counter = 0
    @title_counters = [0]
    @curdivert = nil # The current diversion if active
    @last_divertee = nil
        # last chunk diverted by [[@curdivert]]
    @list_stack = nil
    @in_code = false
    @last_title_level = 0
    @warning_counter = 0
    << Initialise slots of [[Integrator]] .dense >>
    return
  end


The integrator's main entry point.

. [[integrate]]

  def integrate element,
      suppress_indexing: false,
      suppress_narrative: false
    << ? Generate a candidate [[OL_IMPLICIT_TOC]] node >>
    if element.type == OL_TITLE then
      << Integrate the title >>
    elsif element.type == OL_SUBPLOT then
      << Integrate the subplot >>
    elsif element.type == OL_THEMBREAK then
      << Integrate the thematic break >>
    elsif element.type == OL_EXPLICIT_TOC then
      << Integrate the [[.toc]] directive >>
    else
      << Integrate the part of section >>
    end
    return
  end


Title nodes are subject to level depth restriction, are
automatically numbered using three-level identifiers, and are in
addition to [[presentation]] collected into [[toc]].

. "title level too deep" (warning)

<< Integrate the title >>:
  force_section_break
  # Enforce (sub(sub))chapter-locality of diversions
  clear_diversion

  # Check the title's level restriction
  if element.level > @last_title_level + 1 then
    warn element.loc, "title level too deep"
    element.level = @last_title_level + 1
  end
  @last_title_level = element.level

  unless suppress_narrative then
    # Number the title
    while @title_counters.length > element.level do
      @title_counters.pop
    end
    if @title_counters.length < element.level then
      @title_counters.push 0
    end
    @title_counters[-1] += 1
    element.number = @title_counters.join '.'

    # Append the node to [[presentation]] and [[toc]]
    @output.presentation.push element
    @output.toc.push element

    << ? Upgrade [[@toc_candidate]] >>
  end


Subplot nodes function as containers for sequences of section
nodes, other subplot nodes, and thematic breaks.

<< Integrate the subplot >>:
  force_section_break
  # [[force_section_break]] clears [[@in_code]]
  raise 'assertion failed' \
      if @in_code
  # [[subplots can not appear in blockquotes]]
  raise 'assertion failed' \
      if @blockquote

  if @subplot.nil? then
    @output.presentation.push element
  else
    @subplot.elements.push element
  end

  @nesting_stack.push @subplot, @curdivert
  @curdivert = nil
  @blockquote = nil
  @subplot = element


<< in [[Integrator]] >>:
  def end_subplot
    force_section_break
    @blockquote = nil
    @curdivert = @nesting_stack.pop
    raise 'assertion failed' \
        unless @curdivert.nil? or @curdivert.type == OL_DIVERT
    @subplot = @nesting_stack.pop
    raise 'assertion failed' \
        unless @subplot.nil? or @subplot.type == OL_SUBPLOT
    # the [[force_section_break]] above should have ensured that
    # [[@in_code]] is cleared
    raise 'assertion failed' \
        if @in_code
    return
  end


Thematic breaks can appear in two somewhat different kinds of
contexts: in the main presentation, when they can only appear
between sections and thus must force a section break, but also
in blockquotes, where there are no section breaks:

<< Integrate the thematic break >>:
  unless @blockquote then
    force_section_break
    # but won't clear diversion
    unless suppress_narrative then
      @output.presentation.push element
    end
  else
    @blockquote.elements.push element
  end


An manual [[.toc]] cancels the automatic TOC place (if any),
unwinds the title hierarchy down to the top level, and restricts
the subsequent title to top level, too.

<< Integrate the [[.toc]] directive >>:
  clear_diversion
  force_section_break
  unless suppress_narrative then
    raise 'assertion failed' unless @subplot.nil?
    @output.presentation.push element
    if @toc_candidate and
        @toc_candidate.type == OL_IMPLICIT_TOC then
      # cancel the previous automatic TOC placement
      @toc_candidate.type = OL_NOP
    end
    @toc_candidate = element
  end
  while @title_counters.length > 1 do
    @title_counters.pop
  end
  @last_title_level = 0


<< Integrate the part of section >>:
  << ? Upgrade [[OL_BLOCK]] -> [[OL_DIVERTED_CHUNK]] >>
  << New chunk header?  Clear diversion >>
  << ? Break section and warn >>
  << ? Begin new section >>
  if !suppress_narrative and element.type == OL_RUBRIC then
    << Link this rubric to [[toc]] >>
    << ? Upgrade [[@toc_candidate]] >>
  end
  << [[OL_DIVERT]]?  Apply it >>

  if element.type == OL_ITEM then
    << Integrate the list item >>
  elsif element.type == OL_INDEX_ANCHOR then
    << Add [[manual]] index entry >>
  else
    @list_stack = nil
    unless @blockquote then
      @cursec.elements.push element
    else
      @blockquote.elements.push element
    end
    << Chunk or divert?  Parse and cross-reference >>
    << Blockquote starts?  Prepare for content >>

    # If a chunk body is followed by a narrative-type
    # element, we'll want to generate an automatic section
    # break.  To that end, we'll set the [[@in_code]] flag
    # when we encounter a node with a chunk body.
    if element.type & OLF_HAS_CODE != 0 then
      @in_code = true
    end
  end


An indented block can be either a piece of sample code, which is
just shown in the woven output, or a headerless code chunk,
which needs to be tangled, also.  Whether it's one or the other
depends on whether a diversion is in effect; a piece of context
that the parser does not track.  Accordingly, we'll upgrade
[[OL_BLOCK]] nodes to [[OL_DIVERTED_CHUNK]] nodes in the
integrator when a diversion is in effect.

This is also a convenient place to keep track of the chains of
diverted chunks.  To that end, we'll set the [[initial]] flag if
the current divert was not used before, and we'll also point
[[@last_divertee]] to the diverted block so that we can set the
[[final]] flag on it later.

<< ? Upgrade [[OL_BLOCK]] -> [[OL_DIVERTED_CHUNK]] >>:
  if element.type == OL_BLOCK and @curdivert then
    element.type = OL_DIVERTED_CHUNK
    element.name = @curdivert.name
    element.seq = @curdivert.seq
    element.divert = @curdivert

    element.initial = true if @last_divertee.nil?
    @last_divertee = element
  end


<< New chunk header?  Clear diversion >>:
  if element.type & OLF_HAS_HEADER != 0 then
    clear_diversion
  end


As Knuth's original WEB did, we'll generally follow the
rubric-narrative-code structure in our sections, with the main
difference being that multiple chunks can appear in a single
section.  A transition from code to narrative thus causes a
section break, as does any appearance of an [[OL_RUBRIC]] node.

In both cases, we'll warn the user if the section break is not
explicitly marked, usually by two adjacent blank lines.

. "silent section break" (warning)

<< ? Break section and warn >>:
  if (@cursec and
          element.type == OL_RUBRIC) or
      (@in_code and
          element.type & OLF_NARRATIVE != 0) then
    (@cursec.warnings ||= []).push \
        warn(element.loc,
            "silent section break",
            inline: true)
    force_section_break
  end


<< ? Begin new section >>:
  if @cursec.nil? then
    @cursec = OpenStruct.new(
      type: OL_SECTION,
      section_number: nil,
      elements: [],
      loc: element.loc)
    unless suppress_narrative then
      @cursec.section_number =
          @first_section_number + @section_count
      @section_count += 1
      if @subplot.nil? then
        @output.presentation.push @cursec
      else
        @subplot.elements.push @cursec
      end
    end
  end


<< Link this rubric to [[toc]] >>:
  element.section_number = @cursec.section_number
  @output.toc.push element


<< [[OL_DIVERT]]?  Apply it >>:
  if element.type == OL_DIVERT then
    @curdivert = element
    raise 'assertion failed' unless @last_divertee.nil?
  end


Let's now consider blockquotes.

The basic idea of a blockquote is fairly simple: the front-end
parser initiates blockquote mode, then sends a bunch of nodes in
for integration, then clears the blockquote mode.  However,
there are a few tricky points:
- blockquotes are nestable;
- blockquotes do not support active blocks in them but they do
  support indented coded blocks, so diversion needs to be turned
  off for the duration of blockquote mode;
- but whatever diversion was in force before should be restored
  after the blockquote, for blockquotes are purely narrative
  elements that should not affect tangling; and
- thematic breaks, which are normally elements between sections,
  can appear in a blockquote.


. [[@nesting_stack]] (slot of [[Integrator]])

We will thus implement blockquote support by means of a /nesting
stack/, into which the integrator's previous state can be
stashed and later restored.  Its frames are [[OpenStruct]]
records.

<< Initialise slots of [[Integrator]] >>:

  @nesting_stack = []


. [[@blockquote]] (slot of [[Integrator]])

If a blockquote is being parsed, it's pointed to by
[[@blockquote]].  The integration mechanism will check it.

  @blockquote = nil


. [[@subplot]] (slot of [[Integrator]])

If a subplot is being parsed, it's pointed to by [[@subplot]].
The integration mechanism will check it.

  @subplot = nil


The integrator starts a new blockquote when the parser creates
an empty [[OL_BLOCKQUOTE]] node and passes it for integration --
this way, we can use the ordinary rules for integrating
narrative nodes that fit into sections -- and ends it when the
parser calls the [[end_blockquote]] method.

<< Blockquote starts?  Prepare for content >>:
  if element.type == OL_BLOCKQUOTE then
    # [[@in_code]] should be clear at this point --
    # [[OL_BLOCKQUOTE]] is a narrative node type, so even if it
    # was set before, the preparatory code should have performed
    # an automatic section break, which should have cleared
    # [[@in_code]].  Thus, we can restore it to [[false]]
    # without having to save it in the [[@nesting_stack]] frame.
    raise 'assertion failed' \
        if @in_code

    # We won't need to save or restore [[@subplot]] or
    # [[@curdivert]], for these are not supposed to change
    # during the parsing of a blockquote.  We'll just save
    # [[@blockquote]] (which may be [[nil]]).
    @nesting_stack.push @blockquote
    @blockquote = element
  end


. [[end_blockquote]]

<< in [[Integrator]] >>:
  def end_blockquote
    @blockquote = @nesting_stack.pop
    raise 'assertion failed' \
        unless @blockquote.nil? or
            @blockquote.type == OL_BLOCKQUOTE
    @in_code = false
    return
  end


<< Integrate the list item >>:
  # Is this a top-level or descendant item?
  unless @list_stack then
    raise 'assertion failed' unless element.indent == 0

    # Create a new [[OL_LIST]] node.
    new_list = OpenStruct.new(
      type: OL_LIST,
      items: [],
      indent: element.indent)
    unless @blockquote then
      @cursec.elements.push new_list
    else
      @blockquote.elements.push new_list
    end
    @list_stack = [new_list]
  else
    << Discard pending lists deeper than [[element.indent]] >>
    << ? Start a new sublist >>
  end

  # The list structure has been prepared.  Append the
  # new element to the innermost list in progress.
  @list_stack.last.items.push element


. "unexpected dedent" (warning)

<< Discard pending lists deeper than [[element.indent]] >>:
  while @list_stack.last.indent > element.indent do
    if @list_stack[-2].indent < element.indent then
      # Unexpected de-dent, like this:
      #    - master list
      #         - child 1
      #       - child 2
      @list_stack.last.indent = element.indent
      (element.warnings ||= []).push \
          warn(element.loc,
              "unexpected dedent", inline: true)
      break
    end
    @list_stack.pop
  end


<< ? Start a new sublist >>:
  if @list_stack.last.indent < element.indent then
    if @list_stack.last.sublist then
      raise 'assertion failed'
    end
    new_list = OpenStruct.new(
      type: OL_LIST,
      items: [],
      indent: element.indent)
    @list_stack.last.items.last.sublist = new_list
    @list_stack.push new_list
  end


Integrating an index anchor only involves adding an entry to the
index; the [[OL_INDEX_ANCHOR]] node won't be appended into the
body of the containing [[OL_SECTION]] node.

<< Add [[manual]] index entry >>:
  unless suppress_indexing then
    freeform_index_record(element.name).refs.push [
        @cursec.section_number, :manual]
  end


Chunks come out of the parser as series of lines.  For
cross-referencing and tangling, we'll need a slightly more
complex presentation: a sequence of ([[verbatim]]), reference
([[use]] and [[newline]] nodes.  This parsing is done by the
integrator.  (It can't be done in the parser because it can't
tell apart sample code from true chunks if the latter have no
headers.)

Chunk parsing is done in [[parse_chunk_content]] by scanning the
[[lines]] field of the chunk node and constructing a new field,
[[content]], besides it.  [[content]] is not line-oriented;
rather, it has [[newline]] nodes to separate lines.  This makes
the tangling loop a bit simpler.

. [[parse_chunk_content]]

<< in [[Integrator]] >>:
  def parse_chunk_content element
    element.content = []
    element.lines.each_with_index do
        |line, lineno_in_chunk|
      unless lineno_in_chunk.zero? then
        element.content.push \
            OpenStruct.new(type: :newline)
      end
      << Parse a line of chunk content >>
    end
    return
  end


When parsing chunk lines, we'll want to properly pinpoint the
locations of [[use]] nodes so that we can issue correct
warnings.  We'll do this by starting from the number of the
chunk's leftmost column and updating it as we traverse through
the line, which we'll split using [[String#split]] with a
capturing regex.

<< Parse a line of chunk content >>:
  column = 1 + element.indent
  line.split(/(<<\s*
      (?:
       \[\[.*?\]*\]\]
       | .
      )+?
      \s*>>)/x, -1).each_with_index do
        |raw_piece, piece_index|
    << Parse a piece of a line of chunk content >>
    column += raw_piece.length
  end

<< Parse a piece of a line of chunk content >>:
  node = nil
  if piece_index.odd? then
    << Attempt to parse [[raw_piece]] as a [[use]] node >>
    # If failed, [[node]] is still [[nil]].
  end
  if node.nil? and !raw_piece.empty? then
    node = OpenStruct.new(
      type: :verbatim,
      data: raw_piece)
  end
  element.content.push node if node

<< Attempt to parse [[raw_piece]] as a [[use]] node >>:
  name = raw_piece[2 ... -2].strip
      # discard the surrounding double brokets
      # together with adjacent whitespace
  node = OpenStruct.new(type: :use,
      name: nil,
          # for ordering of the [[OpenStruct]]
          # fields; will be set below
      raw: raw_piece,
      loc: OpenStruct.new(
          filename: element.body_loc.filename,
          line: element.body_loc.line +
              lineno_in_chunk,
          column: column)
  )
  << Extract affixes from [[name]] into [[node]] >>
  if !name.empty? then
    node.name =
        Fabricator.canonicalise(name)
  else
    # not a proper reference, after all
    node = nil
  end

<< Extract affixes from [[name]] into [[node]] >>:
  if name =~ /(?:^|\s+)(\|[\w>-]+)$/ and
      Fabricator::POSTPROCESSES.has_key? $1 then
    node.postprocess = $1; name = $`
  end
  if name =~ /(?:^|\s+)(\.dense)$/ then
    node.vertical_separation = $1; name = $`
  end
  if name =~ /^(\.clearindent)(?:\s+|$)/ then
    node.clearindent = true; name = $'
  end


Chunks and diverts we'll be linking under [[chunk_by_name]].
We'll keep separate track of chunk bodies ([[OL_CHUNK]] or
[[OL_DIVERTED_CHUNK]]), linked under
[[chunks_by_name[...].chunks]], and chunk headers ([[OL_CHUNK]]
or [[OL_DIVERT]]), linked under [[chunks_by_name[...].headers]].

<< Chunk or divert?  Parse and cross-reference >>:
  if element.type & OLF_FUNCTIONAL != 0 then
    element.section_number = @cursec.section_number \
        unless suppress_narrative

    cbn_record =
        @output.chunks_by_name[element.name] ||=
            OpenStruct.new(chunks: [], headers: [])

    if element.type & OLF_HAS_HEADER != 0 then
      cbn_record.headers.push element
      << Root?  Check the filename for sanity >>
      << Update [[cbn_record.root_type]] from [[element]] >>
    end

    unless suppress_indexing then
      << Index the definition >>
    end

    if element.type & OLF_HAS_CODE != 0 then
      cbn_record.chunks.push element
      element.ord = (@chunk_ord_counter += 1)
      parse_chunk_content element
      unless suppress_indexing then
        << Create [[transclusion]] index entries >>
      end
    end
  end


. "unuseable filename" (warning)

<< Root?  Check the filename for sanity >>:
  if element.root_type then
    if !Fabricator.filename_sane? element.name then
      (element.warnings ||= []).push \
          warn(element.header_loc,
              "unuseable filename",
              inline: true)
      element.root_type = nil
    end
  end


. [[filename_sane?]]

<< Other methods >>:
  def filename_sane? name
    parts = name.split '/', -1
    return false if parts.empty?
    parts.each do |p|
      return false if ['', '.', '..'].include? p
      return false unless p =~ /\A[\w.-]+\Z/
    end
    return true
  end


The [[:chunks_by_name]] record will hold the highest root type
for chunks of this name, with the order defined as [[nil]] <
[['.file']] < [['.script']].

<< Update [[cbn_record.root_type]] from [[element]] >>:
  if element.root_type and
      cbn_record.root_type.nil? then
    cbn_record.root_type = element.root_type
    @output.roots.push element.name
  end
  if element.root_type == '.script' then
    cbn_record.root_type = element.root_type
  end


<< Index the definition >>:
  case element.type
    << [[case]] clauses to index a [[definition]] >>
    else raise 'assertion failed'
  end


<< [[case]] clauses to index a [[definition]] >>:

For an ordinary chunk, we'll just create a new index reference
entry.

. [[:definition]] (index reference type)

  when OL_CHUNK then
    chunk_index_record(element.name).refs.push [
        @cursec.section_number, :definition]


For a divert, we'll create an index reference entry with a range
in the place of the section number.  Initially, the range will
have the section number the divert appears in as both of its
endpoints.

. [[:definition]] (index reference type)

  when OL_DIVERT then
    index_ref = [@cursec.section_number ..
        @cursec.section_number, :definition]
    chunk_index_record(element.name).refs.push(
        index_ref)
    # We'll add a pointer to this reference entry
    # into [[@curdivert]] so we can replace the
    # range later to cover all the sections in
    # which headerless chunks collected by this
    # divert are present.
    @curdivert.index_ref = index_ref


For a diverted entry, we won't create a new index reference
entry but replace the previously existing one to also include
the new section.

  when OL_DIVERTED_CHUNK then
    prev_range = @curdivert.index_ref[0]
    @curdivert.index_ref[0] = prev_range.begin ..
        @cursec.section_number


. [[:transclusion]] (index reference type)

<< Create [[transclusion]] index entries >>:
  element.content.each do |node|
    next unless node.type == :use
    chunk_index_record(node.name).refs.push [
        @cursec.section_number, :transclusion]
  end


<< in [[Integrator]] >>:

. [[chunk_index_record]]

  def chunk_index_record name
    identifier = "<< " +
        Fabricator.canonicalise(name) +
        " >>"
    markup = [OpenStruct.new(
        type: MU_MENTION_CHUNK,
        name: name)]
    return _index_record identifier, markup
  end


. [[freeform_index_record]]

  def freeform_index_record name
    identifier = Fabricator.canonicalise(name)
    markup = Fabricator.parse_markup name, PF_LINK
    return _index_record identifier, markup
  end


. [[_index_record]] (method of [[Integrator]])

  def _index_record identifier, markup
    return @output.index[identifier] ||=
        OpenStruct.new(
            sort_key: identifier.downcase.sub(
                /^([^[:alnum:]]+)(.*)$/) {
                $2 + ", " + $1},
            canonical_representation: markup,
            refs: [],
        )
  end


This concludes the main integration decision tree.


* Integrator's utilities.

<< in [[Integrator]] >>:

. [[force_section_break]]
. "section with index anchor(s) but no content"

  def force_section_break
    if @cursec and @cursec.elements.empty? then
      # Section nodes are only created when there's at least
      # one element to be integrated.  This element may be an
      # index anchor, which is not actually added into the
      # section's [[elements]] list.  Since this is the only
      # such case, the meaning of [[elements]] being empty by
      # the end of the section is unambiguous.
      (@cursec.warnings ||= []).push \
          warn(@cursec.loc,
              "section with index anchor(s) but no content",
              inline: true)
    end
    @cursec = nil
    @list_stack = nil
    @blockquote = nil
    @in_code = false
    return
  end


In addition to clearing [[@curdivert]], [[clear_diversion]] also
sets the [[final]] flag of the last divertee in a chain.  In
order for this to work properly, the main parser calls this, via
<< Handle the end of fabric >>, once the input fabric ends.

. [[clear_diversion]]
. "unused diversion" (warning)
. "single-use diversion" (warning)

  def clear_diversion
    if @curdivert then
      if !@last_divertee then
        (@curdivert.warnings ||= []).push \
            warn(@curdivert.header_loc,
                "unused diversion",
                inline: true)
      elsif @last_divertee.initial then
        (@curdivert.warnings ||= []).push \
            warn(@curdivert.header_loc,
                "single-use diversion",
                inline: true)
      end
      @curdivert = nil
      @last_divertee.final = true if @last_divertee
      @last_divertee = nil
    end
    return
  end


. space-dash-space ambiguity
In order to resolve the space-dash-space ambiguity, the
front-end parser whether a list is currently active.  It can't
determine that itself because implicit section breaks, which
clear active list status, are generated by the integrator; thus,
it needs to ask the integrator.

. [[in_list?]] (method of [[Integrator]])

  def in_list?
    return !@list_stack.nil?
  end


* Chunk length limit check.

. [[check_chunk_sizes]]
. "long chunk" (warning)
. "very long chunk" (warning)

<< in [[Integrator]] >>:
  def check_chunk_sizes limit
    return unless limit
    @output.presentation.each do |node|
      next unless node.type == OL_SECTION
      node.elements.each do |element|
        next unless (element.type & OLF_HAS_CODE) != 0
        if element.lines.length > limit then
          if element.lines.length > limit * 2 then
            assessment, factor = "very long chunk", 2
          else
            assessment, factor = "long chunk", 1
          end
          limit_loc = element.body_loc.dup
          limit_loc.column = nil
          limit_loc.line += limit * factor
          (element.warnings ||= []).push \
              warn(limit_loc, "%s (%i lines)" %
                      [assessment, element.lines.length],
                  inline: true)
        end
      end
    end
    return
  end


* The warning subsystem.

Warnings are recorded in the [[warnings]] list of a fabric and
may also be recorded in individual elements.
[[Integrator#warn]] generates a record for such storage.  Note
that it does not actually display the warning, for the fabric
loader doesn't really know anything about the I/O system
available for this.

. [[warn]] (method of [[Integrator]])

<< in [[Integrator]] >>:
  def warn location, message, inline: false
    raise 'assertion failed' \
        if location.nil?
    record = OpenStruct.new(
      loc: location,
      message: message,
      number: @warning_counter += 1,
      inline: inline)
    @output.warnings.push record
    return record # so it can also be attached elsewhere
  end


In the command line interface, we'll output the warnings once a
fabric has been fully loaded.

. [[show_warnings]]

<< Other methods >>:
  def show_warnings fabric
    fabric.warnings.each do |warning|
      $stderr.puts "%s: %s" %
          [format_location(warning.loc), warning.message]
    end
    return
  end


* Location pinpointing.

Locations are encoded using [[OpenStruct]] instances with the
fields [[filename]] and [[line]] and optionally [[column]].

<< Other methods >>:

. [[format_location]]

  def format_location h
    if h.column then
      return "%s:%i.%i" % [h.filename, h.line, h.column]
    else
      return "%s:%i" % [h.filename, h.line]
    end
  end


In order to encode a region's location, we'll save its two
endpoints, both inclusive, in an [[OpenStruct]] instance as
[[from]] and [[to]], as standard locations.  The [[dash]] is a
parameter so as to permit n-dash to be used in HTML output.

. [[format_location_range]]

  def format_location_range h, dash: "-"
    if h.from.filename != h.to.filename then
      return format_location(h.from) + dash +
          format_location(h.to)
    else
      if h.from.line != h.to.line then
        result = h.from.filename + ":"
        result << h.from.line.to_s
        result << "." << h.from.column.to_s if h.from.column
        result << dash
        result << h.to.line.to_s
        result << "." << h.to.column.to_s if h.to.column
      else
        result = h.from.filename + ":"
        result << h.from.line.to_s
        if h.from.column or h.to.column then
          result << "." <<
            h.from.column.to_s << dash << h.to.column.to_s
        end
      end
      return result
    end
  end


* Node types.

A parsed fabric's internal representation is, for the most part,
a tree consisting of three layers of different nodes: /outline/
nodes such as titles and paragraphs, /markup/ nodes, and
/sub-chunk/ nodes.  The following constants are used to encode
the types of nodes generated as a fabric is being parsed.

Many of these values are chosen arbitrarily.  Some have special
bit patterns to them.

<< in [[Fabricator]] >>:


Let's first consider the outline nodes' types.  We'll reserve
two bits for the [[OLF_HAS_HEADER]] and [[OLF_HAS_CODE]] flags.

. [[OLF_HAS_HEADER]]
. [[OLF_HAS_CODE]]
. [[OLF_FUNCTIONAL]]

  OLF_HAS_HEADER     = 0x01
  OLF_HAS_CODE       = 0x02
  OLF_FUNCTIONAL     = OLF_HAS_HEADER | OLF_HAS_CODE


We'll also reserve one bit for the [[OLF_NARRATIVE]] flag.  When
the parser (front-end) sees a node with this flag set, it'll
force a section break and warn.  There's no strict need to
attach this flag to [[OL_LIST]], because it's checked by the
parser front-end which sees only items, not lists (as list
containers are built from separate items by the parser's
back-end, [[Integrator]]), nor to [[OL_RUBRIC]], because a
rubric element starts a new section explicitly, but we'll do it
anyway in order to slightly simplify the flag's conceptual
semantics: it marks major narrative nodes.

. [[OLF_NARRATIVE]]

  OLF_NARRATIVE      = 0x08


Now, we can enumerate the node types.

. [[OL_NOP]]
. [[OL_RUBRIC]]
. [[OL_ITEM]]
. [[OL_LIST]]
. [[OL_PARAGRAPH]]
. [[OL_BLOCK]]
. [[OL_DIVERT]]
. [[OL_DIVERTED_CHUNK]]
. [[OL_CHUNK]]
. [[OL_INDEX_ANCHOR]]
. [[OL_THEMBREAK]]
. [[OL_BLOCKQUOTE]]
. [[OL_SUBPLOT]]
. [[OL_IMPLICIT_TOC]]
. [[OL_EXPLICIT_TOC]]

  OL_NOP             = 0x00
  OL_TITLE           = 0x10
  OL_SECTION         = 0x20
  OL_RUBRIC          = 0x30 | OLF_NARRATIVE
  OL_ITEM            = 0x40 | OLF_NARRATIVE
  OL_LIST            = 0x50 | OLF_NARRATIVE
  OL_PARAGRAPH       = 0x60 | OLF_NARRATIVE
  OL_BLOCK           = 0x70 | OLF_NARRATIVE
  OL_DIVERT          = 0x80 | OLF_HAS_HEADER
  OL_DIVERTED_CHUNK  = 0x80 | OLF_HAS_CODE
  OL_CHUNK           = 0x80 | OLF_HAS_HEADER | OLF_HAS_CODE
  OL_INDEX_ANCHOR    = 0x90
  OL_THEMBREAK       = 0xA0 | OLF_NARRATIVE
  OL_BLOCKQUOTE      = 0xB0 | OLF_NARRATIVE
  OL_SUBPLOT         = 0xC0
  OL_IMPLICIT_TOC    = 0xD0
  OL_EXPLICIT_TOC    = 0xE0


Next, we'll consider the markup nodes.  First, in
[[Markup_Constructor#words]], which is frequently called as it
has to process all the narrative content of a fabric, we parse
free-flow text by regex-splitting a paragraph at space, and
iterating over the result using [[each_with_index]].  The markup
nodes thus generated have a natural checkerboard pattern: the
zeroth one necessarily has type [[MU_PLAIN]], the next one
[[MU_SPACE]], then again [[MU_PLAIN]], and so on.  By choosing
[[MU_PLAIN]] to be zero and [[MU_SPACE]] to be one, we can
translate the index of a piece into its markup node type value
with only one arithmetic operation -- [[i & 1]], and won't have
to use branching of any sort.

. [[MU_PLAIN]]
. [[MU_SPACE]]
. [[MU_BOLD]]
. [[MU_ITALIC]]
. [[MU_UNDERSCORE]]
. [[MU_MONOSPACE]]
. [[MU_LINK]]
. [[MU_MENTION_CHUNK]]
. [[MU_SPECIAL_ATOM]]

  MU_PLAIN           = 0x00
  MU_SPACE           = 0x01
  MU_BOLD            = 0x03
  MU_ITALIC          = 0x04
  MU_UNDERSCORE      = 0x05
  MU_MONOSPACE       = 0x06
  MU_LINK            = 0x07
  MU_MENTION_CHUNK   = 0x08
  MU_SPECIAL_ATOM    = 0x09


Finally, the special atoms.

. [[SA_NBSP]]
. [[SA_NDASH]]
. [[SA_MDASH]]
. [[SA_ELLIPSIS]]

  SA_NBSP      = 0x01
  SA_NDASH     = 0x02
  SA_MDASH     = 0x03
  SA_ELLIPSIS  = 0x04


== Horizontal parsing

* Markup parsing.

The markup parser materialises as a function that takes a string
as its input and returns a list of syntactic nodes.  The parser
itself is a fairly simple linear scanner, the main trick being
[[Markup_Parser_Stack]] that holds the currently open markup
constructs.

. [[parse_markup]]

<< Other methods >>:
  def parse_markup s, suppress_modes = 0
    ps = Fabricator::Pointered_String.new s
    stack = Fabricator::Markup_Parser_Stack.new suppress_modes
    while ps.pointer < s.length do
      << Parse a bit of markup >>
    end
    while stack.length > 1 do
      stack.unspawn
    end
    return stack.last.content
  end


So, let's consider [[Markup_Parser_Stack]] next.  Since it's a
stack, we'll derive it from [[Array]]:

. [[Markup_Parser_Stack]]

<< in [[Fabricator]] >>:
  class Markup_Parser_Stack < Array
    << in [[Markup_Parser_Stack]] >>
  end


At initialisation, the stack will have one frame.  We'll
[[content]] holds collected markup nodes in a
[[Markup_Constructor]] instance (which inherits from [[Array]]);
[[mode]] is a bitfield bit, as used in mode, but it is not a
bitfield.  for currently permitted markup notations, and
[[term_type]] is implement stack frames as [[OpenStruct]]
instances.  The slot the frame marker for unwinding.
[[term_type]] normally holds a

<< in [[Markup_Parser_Stack]] >>:
  def initialize suppress_modes = 0
    super()
    push OpenStruct.new(
        content: Fabricator.markup,
        mode: PF_DEFAULTS & ~suppress_modes,
        term_type: 0,
      )
    return
  end


Next, let's list all the bits a [[Markup_Parser_Stack]] frame's
[[mode]] can hold:

<< in [[Fabricator]] >>:
  PF_BOLD            = 0x01
  PF_END_BOLD        = 0x02
  PF_ITALIC          = 0x04
  PF_END_ITALIC      = 0x08
  PF_UNDERSCORE      = 0x10
  PF_END_UNDERSCORE  = 0x20
  PF_LINK            = 0x40
  PF_END_LINK        = 0x80

  PF_DEFAULTS = PF_BOLD | PF_ITALIC | PF_UNDERSCORE |
      PF_LINK


Whenever the markup parser encounters what looks like a markup
start notation, it /spawns/ a new frame onto the stack.  The new
frame will contain the notation as [[face]] so that we can
[[unspawn]] it, should the start later turn out to be a false
start.  It overrides the [[mode]] of the top stack frame by
enabling the corresponding markup's end notation and disabling
another start notation of the same kind.  Finally, it tags the
new frame with a [[term_type]], which is used in order to find
this stack frame when we actually get to the end notation.

[[OpenStruct]]'s flexibility lets us add extra fields when
needed.  This is useful for dealing with links, as we'll see
later.

<< in [[Markup_Parser_Stack]] >>:

. [[spawn]] (method of [[Markup_Parser_Stack]])

  def spawn face, start_flag, end_flag
    self.push OpenStruct.new(
      face: face,
      content: Fabricator.markup,
      mode: self.last.mode & ~start_flag | end_flag,
      term_type: end_flag,
    )
    return
  end


The frame can be merged back into its parent frame by
/unspawning/ it.  This happens when we need to reinterpret what
once looked like a start notation as a plain piece of string.

. [[unspawn]]

  def unspawn
    raise 'assertion failed' unless length >= 2
    top = self.pop
    self.last.content.
        plain(top.face).
        concat(top.content)
    return
  end


Finally, when we encounter a valid markup end notation, we'll
wrap up the current stack frame, /ennoding/ its [[content]] into
the matching ancestral stack frame's.  Because the markup region
may contain a few intervening faux start notations, we may have
to first unspawn a few times; the [[frame_type]] parameter will
tell [[ennode]] how to recognise the last stack frame to eat up.

. [[ennode]]

  def ennode node_type, frame_type, **attr
    while self.last.term_type != frame_type do
      self.unspawn
    end
    top = self.pop
    self.last.content.node node_type,
        content: top.content,
        **attr
    return
  end


Let's now consider the main markup parsing loop.  We'll set it
up as a series of [[if ... elsif ... elsif ... end]] clauses.

The easiest markup to parse is undoubtedly [[[[foo]]]] for
monospaced text, which doesn't even need a stack frame.  The
main trick here is that if the terminal [[]]]] contains more
than two adjacent closing brackets, we'll pick the two last
ones.  This trick, originally from Norman Ramsey's [[noweb]],
lets the user to use multiple terminal closing brackets in a
natural manner, as in [[[[a[b[i]]]]]].

When parsing the monospaced string, we'll split it into
[[MU_PLAIN]] and [[MU_SPACE]] nodes.  This is one of the rare
cases in Maui's notation when whitespace needs to be recorded,
for we'll want to retain sequences of multiple whitespaces in
monospaced text.

<< Parse a bit of markup >>:
  if ps.at? "[[" and
      end_offset = s.index("]]", ps.pointer + 2) then
    while ps[end_offset + 2] == ?] do
      end_offset += 1
    end
    stack.last.content.node MU_MONOSPACE,
        content: Fabricator.markup.
            words(ps[ps.pointer + 2 ... end_offset].strip)
    ps.pointer = end_offset + 2


Detecting the notation for *bold*, /italic/, or _underscore_ is
a bit more complicated, so we'll encapsulate it in a separate
function.  Since it operates on a [[Pointered_String]], we'll
insert it into it as an extra method.

The main rules are:
- the starting character is alone, not next to another copy of
  itself, and
- the starter is not immediately followed by a whitespace.

. [[biu_starter?]]

<< in [[Pointered_String]] >>:
  def biu_starter? c
    return char_ahead == c &&
        char_ahead(-1) != c &&
        ![?\s, c].include?(char_ahead(1))
  end


When these conditions trigger, we'll establish a new markup
parser stack frame:

<< Parse a bit of markup >>:
  elsif stack.last.mode & PF_BOLD != 0 and
      ps.biu_starter? ?* then
    stack.spawn '*', PF_BOLD, PF_END_BOLD
    ps.pointer += 1

  elsif stack.last.mode & PF_ITALIC != 0 and
      ps.biu_starter? ?/ then
    stack.spawn '/', PF_ITALIC, PF_END_ITALIC
    ps.pointer += 1

  elsif stack.last.mode & PF_UNDERSCORE \
          != 0 and
      ps.biu_starter? ?_ then
    stack.spawn '_', PF_UNDERSCORE, PF_END_UNDERSCORE
    ps.pointer += 1


The conditions for BIU-terminating markup are similar, except
in this case, we'll prohibit whitespace /preceding/ the
markup character.

. [[biu_terminator?]]

<< in [[Pointered_String]] >>:
  def biu_terminator? c
    return char_ahead == c &&
        char_ahead(1) != c &&
        ![?\s, c].include?(char_ahead(-1))
  end


The parser's rules are similarly straightforward, too.

<< Parse a bit of markup >>:

  elsif stack.last.mode & PF_END_BOLD != 0 and
      ps.biu_terminator? ?* then
    stack.ennode MU_BOLD, PF_END_BOLD
    ps.pointer += 1

  elsif stack.last.mode & PF_END_ITALIC != 0 and
      ps.biu_terminator? ?/ then
    stack.ennode MU_ITALIC, PF_END_ITALIC
    ps.pointer += 1

  elsif stack.last.mode & PF_END_UNDERSCORE != 0 and
      ps.biu_terminator? ?_ then
    stack.ennode MU_UNDERSCORE, PF_END_UNDERSCORE
    ps.pointer += 1


Let's now move on to parsing links.

Maui's basic link notation is [[<override|target>]], or when
override is not desired, just [[<target>]].  This presents a
slight conundrum, in that when we pass the initial [[<]], we
don't yet know whether we should parse the following as
marked-up text -- for the /override/ -- or as a plain string --
for /target/.  We'll resolve this by beginning parsing as plain
text, but storing the offset of the initial broket in the stack
frame as [[start_offset]] so we can return to the beginning,
should we encounter the terminal [[>]] without an intervening
[[|]].

  elsif stack.last.mode & PF_LINK != 0 and
      ps.biu_starter? ?< then
    stack.spawn '<', PF_LINK, PF_END_LINK
    stack.last.start_offset = ps.pointer
    ps.pointer += 1


When we see [[|]], we have completed parsing the link's
override.  We can now pick up the plain-text link target,
terminated by [[>]], and wrap up the link node.

  elsif stack.last.mode & PF_END_LINK != 0 and
      ps.at? '|' and
      end_offset = s.index(?>, ps.pointer + 1) then
    target = ps[ps.pointer + 1 ... end_offset]
    # Remove the 'soft hyphenation' for URLs
    target = target.gsub(/%\s+/, '')
    if link_like? target then
      stack.ennode MU_LINK, PF_END_LINK,
          target: target
      ps.pointer = end_offset + 1
    else
      # False alarm: this is not a link, after all.
      stack.cancel_link
      stack.last.content.plain '|'
      ps.pointer += 1
    end


When we see [[>]] with [[END_LINK]] enabled, we know that
this is an unoverridden link.  The text between the brokets is
now supposed to be plain text link, any markup-like looking
symbols such as underscores or slashes notwithstanding, so we'll
discard the work we did trying to parse this as markup, and
construct a simple link node.

  elsif stack.last.mode & PF_END_LINK != 0 and
      ps.at? '>' then
    j = stack.rindex do |x|
      x.term_type == PF_END_LINK
    end
    target = ps[stack[j].start_offset + 1 ... ps.pointer]
    # Remove the URL's 'soft hyphenation' but keep it for
    # the link's face
    solidified_target = target.gsub(/%\s+/, '')
    if link_like? solidified_target then
      stack[j .. -1] = []
      stack.last.content.node MU_LINK,
          implicit_face: true,
          target: solidified_target,
          content: Fabricator.markup.plain(target)
    else
      # False alarm: this is not a link, after all.
      stack.cancel_link
      stack.last.content.plain '>'
    end
    ps.pointer += 1


The [[link_like?]] test lets us avoid misinterpreting some
(very) basic broketed constructs such as [[<*>]] --- which may
appear when Maui wikitext is generated by copy-pasting
ASCII-formatted text --- as links.

. [[link_like?]]

<< Other methods >>:
  def link_like? s
    return !!(s =~ /\A(?:#\s*)?[[:alnum:]]/)
  end


When an apparent link turns out to not be a link at all, we'll
/cancel/ it.  This involves clearing the [[END_LINK]] flag
(and the relevant [[term_type]]) in all affected stack frames
and restoring the [[LINK]] flag so that we can parse another,
more proper link.  (Note that we can always restore [[LINK]]:
[[cancel_link]] is only called if we were in [[END_LINK]]
mode, and this makes only sense if, at a previous point in
parsing, we had [[LINK]] set and encountered an opening broket.)
We can't perform unwinding at this point because we may have
passed over starts of some markup regions which have not ended
yet but will end later.

. [[cancel_link]] (method of [[Markup_Parser_Stack]])

<< in [[Markup_Parser_Stack]] >>:
  def cancel_link
    i = self.length
    begin
      i -= 1
      self[i].mode &= ~PF_END_LINK
      self[i].mode |= PF_LINK
    end until self[i].term_type == PF_END_LINK
    self[i].term_type = 0
    return
  end


Because whitespace has meaning for Maui markup --- it indicates
places suitable for linebreaks when word-wrapping ---, we'll
parse it as a kind of special node.  Because en-dash necessarily
follows whitespace, we'll also check this here.

<< Parse a bit of markup >>:

  elsif ps.at? ' ' then
    ps.pointer += 1
    while ps.at? ' ' do
      ps.pointer += 1
    end
    stack.last.content.space
    << Parse a bit of markup after whitespace >>


. [[MU_SPECIAL_ATOM]], construction
. [[SA_NBSP]]
. non-breakable space, parsing

We'll consider the [[U+00A0 NO-BREAK SPACE]] a form of markup --
namely, a special atom.  Each such character will be a node of
the type [[MU_SPECIAL_ATOM]], with a [[subtype]] attribute of
[[SA_NBSP]].

  elsif ps.at? "\u00A0" then
    stack.last.content.node MU_SPECIAL_ATOM,
        subtype: SA_NBSP
    ps.pointer += 1


The same approach works on the em-dash, including its ASCII
representation, the ellipsis, and the Unicode representation of
the en-dash.


. [[MU_SPECIAL_ATOM]], construction
. [[SA_MDASH]]
. em-dash, parsing, ASCII representation

  elsif ps.at? "--" then
    stack.last.content.node MU_SPECIAL_ATOM,
        subtype: SA_MDASH
    ps.pointer += 2


. [[MU_SPECIAL_ATOM]], construction
. [[SA_MDASH]]
. em-dash, parsing, Unicode representation

  elsif ps.at? "\u2014" then
    stack.last.content.node MU_SPECIAL_ATOM,
        subtype: SA_MDASH
    ps.pointer += 1


. [[MU_SPECIAL_ATOM]], construction
. [[SA_ELLIPSIS]]
. ellipsis, parsing, ASCII representation

  elsif ps.at? "..." then
    stack.last.content.node MU_SPECIAL_ATOM,
        subtype: SA_ELLIPSIS
    ps.pointer += 3


. [[MU_SPECIAL_ATOM]], construction
. [[SA_NDASH]]
. en-dash, parsing, Unicode representation

  elsif ps.at? "\u2013" then
    stack.last.content.node MU_SPECIAL_ATOM,
        subtype: SA_NDASH
    ps.pointer += 1


. [[MU_SPECIAL_ATOM]], construction
. [[SA_NDASH]]
. en-dash, parsing, ASCII representation

The ASCII representation of the en-dash is slightly more
complicated.  It necessarily has to follow whitespace and be
followed by whitespace, so we'll check for this in the aftermath
of parsing ordinary whitespace.

<< Parse a bit of markup after whitespace >>:
  if ps.at? '- ' then
    stack.last.content.node MU_SPECIAL_ATOM,
        subtype: SA_NDASH
    ps.pointer += 1 # leave the following space in place
  end


Finally, if none of the rules matched, we'll pick the following
character up as a plain text node.  As an optimisation, we'll
merge it with any following characters that definitely are not
markup characters.  Since we don't want the generated node's
[[data]] field to retain the type of [[Pointered_String]], we'll
construct a new [[String]] instance with its content.

<< Parse a bit of markup >>:
  else
    j = ps.pointer + 1
    while j < s.length and
        !" *-./<>[_|\u00A0\u2013\u2014".include? ps[j] do
      j += 1
    end
    stack.last.content.plain(
        String.new(ps[ps.pointer ... j]))
    ps.pointer = j
  end


* String traversal.

The final part of the markup parser's puzzle is
[[Pointered_String]], which provides convenient lookahead (and
lookbehind) while traversing the string.  We'll derive it from
[[String]] by augmenting it with the [[pointer]] field.

. [[Pointered_String]]

<< in [[Fabricator]] >>:
  class Pointered_String < String
    def initialize value
      super value
      @pointer = 0
      return
    end

    attr_accessor :pointer

    << in [[Pointered_String]] >>
  end


The most basic operation is extracting up to a given number of
characters of lookahead.

<< in [[Pointered_String]] >>:

. [[ahead]] (method of [[Pointered_String]])

  def ahead length
    return self[@pointer, length]
  end


An alternative way of lookahead extracts only a single
character, specified via a relative offset from [[@pointer]].
The [[delta]] parameter can be negative for lookbehind, and
attempts to look before the string begins produce [[nil]] rather
than wrapping over to the end of the string.

. [[char_ahead]] (method of [[Pointered_String]])

  def char_ahead delta = 0
    offset = @pointer + delta
    return offset >= 0 ? self[offset] : nil
  end


Parsing decisions often depend on whether the current lookahead
matches an etalon.  We'll call this operation [[at?]].

. [[at?]] (method of [[Pointered_String]])

  def at? etalon
    return ahead(etalon.length) == etalon
  end


There is no point in implementing basic methods for moving
[[@pointer]] around, as it has already been fully exposed.


* Construction outside parser.

In order to simplify constructing the markup structures, we'll
subclass [[Array]] into a variant with methods for the markup
node types.  Calling any such a method results in appending a
matching [[OpenStruct]] to the array.

. [[markup]] (procedure)

<< Other methods >>:
  def markup
    return Fabricator::Markup_Constructor.new
  end

. [[Markup_Constructor]]

<< in [[Fabricator]] >>:
  class Markup_Constructor < Array
    << in [[Markup_Constructor]] >>
  end


Let's first write an abstract appender and specialise it later.

<< in [[Markup_Constructor]] >>:

. [[node]] (method of [[Markup_Constructor]])

  def node type, **attr
    return push(OpenStruct.new(type: type, **attr))
    # [[Array#push]] will return self, allowing [[node]] calls
    # to be chained.
  end


. [[plain]] (method of [[Markup_Constructor]])

  def plain data
    return node(MU_PLAIN, data: data)
  end


. [[space]] (method of [[Markup_Constructor]])

  def space data = nil
    return node(MU_SPACE, data: data)
  end


Now, in order to have some convenience atop our convenience,
we'll define the [[words]] method that will parse a given string
into 'whitespace' and 'other'.  This distinction in the markup
is necessary to make sure the whitespace can be broken when
word-wrapping the result.

. [[words]] (method of [[Markup_Constructor]])

  def words s
    s.split(/(\s+)/, -1).each_with_index do |part, i|
      # Note that 0 is [[MU_PLAIN]] and 1 is [[MU_SPACE]].
      node(i & 1, data: part)
    end
    return self
  end


* Chunk name canonicalisation.

This amounts to compressing all whitespace that is not marked as
monospaced by double brackets.

. [[canonicalise]]

<< Other methods >>:
  def canonicalise raw_name
    name = ''
    raw_name.strip.split(/(\[\[.*?\]*\]\])/, -1).
        each_with_index do |part, i|
      part.gsub! /\s+/, ' ' if i.even?
      name << part
    end
    return name
  end


== Tangling

* The main tangling loop.

Our tangler does not treat the parsed fabric as a purely passive
object; rather, it adds cross-references, annotates chunks with
the output locations, and issues warnings over reference
problems.  Thus, it lives inside the [[Integrator]].  In order
to not mislead the programmer to think it's the top-level
tangling method, we'll give it a more specific name:
[[tangle_chunks]].

It takes four parameters: [[cbn_entry]] is the
[[chunks_by_name]] entry of the node to be tangled (we'll pass a
pre-resolved node so as to prevent resolution failure at this
point), [[sink]] is the [[Tangling_Sink]] instance to use,
[[trace]] is a [[Set]] used to detect circular references, and
[[vsep]] can override the number of linebreaks to be generated
between adjacent chunks.  By default, we'll leave one blank
line, hence two linebreaks.  The [[.dense]] option removes the
blank line, leaving only one separating linebreak.

During tangling, we'll collect each chunk's tangling locations.
(Note that it's possible that one chunk will be tangled into
multiple places).  We'll store this data into the chunk as the
[[tangle_locs]] list.  We'll also collect tangling locations of
chunk chains -- sequences of [[OL_DIVERTED_CHUNK]] elements
diverted by the same divert.  We'll store this data into the
[[OL_DIVERT]] node as the [[chain_tangle_locs]] list.

. [[tangle_chunks]]

<< in [[Integrator]] >>:
  def tangle_chunks cbn_entry, sink, trace, vsep = 2
    chain_start_loc = nil
    chunks = cbn_entry.chunks.sort_by do |c|
      [c.seq || 1000, c.ord]
    end

    chunks.each_with_index do |chunk, i|
      vsep.times{sink.newline} unless i.zero?
      if chunk.divert and chunk.initial then
        raise 'assertion failed' if chain_start_loc
        chain_start_loc = sink.location_ahead
      end
      << Tangle [[chunk]] to [[sink]] >>
      if chunk.divert and chunk.final then
        raise 'assertion failed' unless chain_start_loc
        (chunk.divert.chain_tangle_locs ||= []).push \
            OpenStruct.new(
                from: chain_start_loc,
                to: sink.location_behind)
        chain_start_loc = nil
      end
    end
    return
  end


In addition to expanding the chunk's content to [[sink]], we'll
also record its location in the output file, as kept track by
[[Tangling_Sink]].

<< Tangle [[chunk]] to [[sink]] >>:
  start_location = sink.location_ahead
  chunk.content.each do |node|
    case node.type
    when :verbatim then
      sink.write node.data
    when :newline then
      sink.newline
    when :use then
      tangle_transclusion node, sink, trace, chunk
    else raise 'data structure error'
    end
  end
  end_location = sink.location_behind

  # Both endpoints are inclusive.
  (chunk.tangle_locs ||= []).push OpenStruct.new(
    from: start_location,
    to: end_location)


For circular or dangling references, we'll write the raw
transclusion directive, as it appeared in the fabric, to output.
It's possible that we mistakenly parsed something that was not
intended as a reference, and while this should be fixed by
appropriate escaping (or, well, dividing the bogus reference
onto multiple code lines), this non-destructive approach is
probably optimal as workarounds go.

. [[tangle_transclusion]]
. "circular reference" (warning)
. "dangling reference" (warning)

<< in [[Integrator]] >>:
  def tangle_transclusion node, sink, trace, referrer
    name = node.name
    if trace.include? name then
      warn node.loc, "circular reference"
      sink.write node.raw
    else
      cbn_entry = @output.chunks_by_name[name]
      if cbn_entry.nil? or cbn_entry.chunks.empty? then
        warn node.loc, "dangling reference"
        sink.write node.raw
      else
        << Cross-reference the transclusion >>
        << Recurse and transclude >>
      end
    end
    return
  end


<< Cross-reference the transclusion >>:
  (cbn_entry.transcluders ||= []).push(
      OpenStruct.new(
        name: referrer.name,
        section_number: referrer.section_number,
        ))


<< Recurse and transclude >>:
  trace.add name
  if node.postprocess then
    # redirect the tangler
    outer_sink = sink
    inner_sport = StringIO.new
    sink = Fabricator::Tangling_Sink.new '(pipe)',
        inner_sport
  end
  sink.pin_indent node.clearindent ? 0 : nil do
    tangle_chunks cbn_entry, sink, trace,
        node.vertical_separation == '.dense' ? 1 : 2
  end
  if node.postprocess then
    # revert the redirect and apply the filter
    sink.newline
    filter_output =
        Fabricator::POSTPROCESSES[node.postprocess].
        call(inner_sport.string)
    sink = outer_sink
    sink.pin_indent node.clearindent ? 0 : nil do
      sink.write_long filter_output
    end
  end
  trace.delete name


<< in [[Fabricator]] >>:
  POSTPROCESSES = {
    '|scss->css' => proc do |input|
      require 'sass'
      Sass::Engine.new(input,
          syntax: :scss,
          load_paths: [],
          filename: '(pipe)').render
    end,

    '|sass->css' => proc do |input|
      require 'sass'
      Sass::Engine.new(input,
          syntax: :sass,
          load_paths: [],
          filename: '(pipe)').render
    end,

    '|cs->js' => proc do |input|
      require 'coffee-script'
      CoffeeScript.compile input
    end,
  }


* Tangle all the files.

The high-level tangling interface, [[Integrator#tangle_roots]],
sets up the [[tangles]] branch in the fabric.  (For idempotency,
it does nothing if it already exists.  This is mainly useful
because it calls [[tangle_chunks]] which has the side effect of
inserting cross-reference information into the fabric.)

. [[tangle_roots]]

<< in [[Integrator]] >>:
  def tangle_roots
    return if @output.tangles
    @output.tangles = {}
    @output.roots.each do |name|
      sport = StringIO.new
      sink = Fabricator::Tangling_Sink.new name, sport
      cbn_entry = @output.chunks_by_name[name]
      # We can assume that [[cbn_entry]] is not [[nil]], for
      # otherwise there wouldn't be a [[roots]] entry.
      tangle_chunks cbn_entry, sink, Set.new([name])
      sink.newline
      @output.tangles[name] = OpenStruct.new(
        filename: name,
        root_type: cbn_entry.root_type,
        content: sport.string,
        line_count: sink.line_count,
        nonblank_line_count: sink.nonblank_line_count,
        longest_line_length: sink.longest_line_length,
      )
    end
    return
  end


Finally, at the command line interface level, we'll just need to
call [[tangle_roots]] and write the results into files.  The
latter is done through the [[writeout_plan]] abstraction layer.

<< Tangle all roots >>:
  integrator.tangle_roots

. [[plan_to_write_out]]

<< Other methods >>:
  # Take a [[results]] record from tangling and construct a
  # matching [[proc]] to be stored in the [[writeout_plan]].
  def plan_to_write_out results
    return proc do |output_filename|
      File.write output_filename, results.content
      puts "Tangled #{results.filename},"
      if results.line_count != 1 then
        print "  #{results.line_count} lines"
      else
        print "  #{results.line_count} line"
      end
      puts " (#{results.nonblank_line_count} non-blank),"
      if results.longest_line_length != 1 then
        puts "  longest #{results.longest_line_length} chars."
      else
        puts "  longest #{results.longest_line_length} char."
      end
      << Script root?  Make executable >>
    end
  end


<< Script root?  Make executable >>:
  if results.root_type == '.script' and
      !Fabricator::WINDOWS_HOSTED_P then
    stat = File.stat output_filename
    m = stat.mode
    uc = ""
    [(m |= 0o100), (uc << "u")] if m & 0o400 != 0
    [(m |= 0o010), (uc << "g")] if m & 0o040 != 0
    [(m |= 0o001), (uc << "o")] if m & 0o004 != 0
    File.chmod m, output_filename
    puts "Set %s+x on %s, resulting in %03o" % [
      uc,
      output_filename,
      m & 0o777,
    ]
  end

<< in [[Fabricator]] >>:
  WINDOWS_HOSTED_P =
      (RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/)


=== The tangling sink.

* The tangling sink.

The tangling sink serves as a back-end to the tangling loop,
taking care of indentation, right-stripping the generated lines,
and keeping track of the output location so as to permit
cross-referencing chunks with where they appear in the generated
files.

. [[Tangling_Sink]]

<< in [[Fabricator]] >>:
  class Tangling_Sink
    def initialize filename, port
      super()
      @filename = filename
      @port = port
      @lineno = 1
      @line = ''
      @indent = 0
      << Initialise statistical trackers >>
      return
    end

    << in [[Tangling_Sink]] >>
  end

<< in [[Tangling_Sink]] >>:


* Simple output.

. [[write]] (method of [[Tangling_Sink]])

  def write s
    @line << s
    return
  end


. [[newline]] (method of [[Tangling_Sink]])

  def newline
    @line.rstrip!
    @port.puts @line
    @lineno += 1
    << Count [[@line]] for statistics >>
    @line = ' ' * @indent
    return
  end


We'll use Ruby's block idiom for indentation.  By default,
[[pin_indent]] will retain the current column as the beginning
column for lines beginning during the thunk passed to it.  The
amount of indentation can be overridden by passing it to
[[pin_indent]] as a parameter.  (The parameter of [[nil]] can be
used to explicitly request the implicit behaviour.)  Such an
override is used to implement the [[.clearindent]] directive.

. [[pin_indent]]

  def pin_indent level = nil
    previous_indent = @indent
    begin
      @indent = level || @line.length
      yield
    ensure
      @indent = previous_indent
    end
    return
  end


A filter's output is written into a sink as a long multiline
string.  Note that we'll ignore trailing linebreaks in such a
string.

. [[write_long]] (method of [[Tangling_Sink]])

  def write_long s
    s.split(/\n/).each_with_index do |line, i|
      newline unless i.zero?
      write line
    end
    return
  end


* Location tracking.

. [[location_ahead]] (method of [[Tangling_Sink]])

  def location_ahead
    return OpenStruct.new(
      filename: @filename,
      line: @lineno,
      column: @line.length + 1)
  end


. [[location_behind]] (method of [[Tangling_Sink]])

  def location_behind
    return OpenStruct.new(
      filename: @filename,
      line: @lineno,
      column: @line.length)
  end


* And finally, statistics.

The number of output lines is easily calculated from the line
number tracker.

. [[line_count]] (method of [[Tangling_Sink]])

  def line_count
    return @lineno - 1
  end


The number of processed sections does not even need any
calculation.

<< in [[Integrator]] >>:
  attr_reader :section_count


In order to count non-blank lines, we need a separate counter.

<< Initialise statistical trackers >>:
  @nonblank_line_count = 0

<< in [[Tangling_Sink]] >>:
  attr_reader :nonblank_line_count

<< Count [[@line]] for statistics >>:
  @nonblank_line_count += 1 unless @line.empty?


We also want to find out the generated file's width.

<< Initialise statistical trackers >>:
  @longest_line_length = 0

<< in [[Tangling_Sink]] >>:
  attr_reader :longest_line_length

<< Count [[@line]] for statistics >>:
  @longest_line_length = @line.length \
      if @line.length > @longest_line_length

== Fabric loader's façade

For user's convenience, we'll encapsulate the parsing,
integration, and tangling of a fabric into a single procedure.

. [[load_fabric]]

<< Other methods >>:
  def load_fabric input, chunk_size_limit: 24,
      bases: []
    integrator = Fabricator::Integrator.new
    bases.each do |base|
      File.open base, 'r' do |port|
        parse_fabric_file port, integrator,
            suppress_narrative: true,
            suppress_indexing: true
      end
    end
    raise 'assertion failed' \
        unless integrator.section_count.zero?
    parse_fabric_file input, integrator
    << Tangle all roots >>
    integrator.check_chunk_sizes(chunk_size_limit)
    return integrator.output
  end

== Weaving

=== Coloured text

* Coloured text.

This output mode is convenient for use in a modern (x)terminal.

<< Weave [[fabric]] (ctxt) >>:
  open filename, 'w' do |port|
    symbolism = $cmdline.symbolism.dup
    symbolism.chunk_name_delim ||=
        if $cmdline.pseudographics ==
            Fabricator::ASCII_PSEUDOGRAPHICS then
          "<\<" .. ">>"
        else
          Fabricator.default_symbolism.chunk_name_delim
        end

    Fabricator.weave_ctxt fabric, port,
        width: $cmdline.output_width,
        symbolism: symbolism,
        pseudographics: $cmdline.pseudographics
  end
  puts "Weaved #{filename}"


. [[weave_ctxt]]

<< Other methods >>:
  def weave_ctxt fabric, port,
      width: 80,
      symbolism: default_symbolism,
      pseudographics: Fabricator::UNICODE_PSEUDOGRAPHICS
    wr = Fabricator::Text_Wrapper.new port,
        width: width,
        pseudographics: pseudographics
    << Weave fabric's warnings (ctxt) >>
    fabric.presentation.each do |element|
      wr.vseparate
      weave_ctxt_plot_element element, fabric, wr,
          symbolism: symbolism
    end
    unless fabric.index.empty? then
      << Weave index (ctxt) >>
    end
    return
  end

<< Weave fabric's warnings (ctxt) >>:
  unless fabric.warnings.empty? then
    wr.styled :section_title do
      wr.add_plain 'Warnings'
    end
    wr.linebreak
    wr.linebreak
    weave_ctxt_warning_list fabric.warnings, wr
    wr.linebreak
  end


Since warning lists can be output not only in the beginning of
the woven fabric but also inline, we'll implement this as a
procedure.

We'll want to be able to pass any random node's [[.warnings]] to
[[weave_ctxt_warning_list]] even if there aren't any warnings.
To that end, we'll first pass the [[list]] parameter through
[[#to_a]], which is a no-op for proper arrays but maps [[nil]]
to an empty list.

. [[weave_ctxt_warning_list]]

<< Other methods >>:
  def weave_ctxt_warning_list list, wr, inline: false,
      indent: true
    list.to_a.each do |warning|
      wr.styled inline ? :inline_warning : :null do
        wr.add_plain (indent ? '  ' : '') + '!!! ' if inline
        wr.add_plain format_location(warning.loc)
        wr.add_plain ':'
        wr.add_space
        wr.hang do
          warning.message.split(/(\s+)/).
              each_with_index do |part, i|
            if i.even? then
              wr.add_plain part
            else
              wr.add_space part
            end
          end
        end
      end
      wr.linebreak
    end
    return
  end


. [[weave_ctxt_plot_element]]

<< Other methods >>:
  def weave_ctxt_plot_element element, fabric, wr,
      symbolism: default_symbolism
    case element.type
    << [[weave_ctxt_plot_element]] rules >>
    else raise 'data structure error'
    end
    return
  end


<< [[weave_ctxt_plot_element]] rules >>:

  when OL_TITLE then
    << Weave the title (ctxt) >>


  when OL_SUBPLOT then
    << Weave the subplot (ctxt) >>


  when OL_SECTION then
    << Weave the section (ctxt) >>


  when OL_THEMBREAK then
    wr.width.times do
      wr.add_pseudographics :thematic_break_char
    end
    wr.linebreak


  when OL_NOP then
    # no operation


  when OL_IMPLICIT_TOC, OL_EXPLICIT_TOC then
    weave_ctxt_toc fabric.toc, wr,
        symbolism: symbolism


<< Weave the subplot (ctxt) >>:
  wr.add_pseudographics :subplot_leadin
  wr.linebreak
  wr.add_pseudographics :subplot_margin
  # A subplot's ends are already separated.
  wr.vsep = 2
  wr.hang wr.hangindent + 2,
      wr.pseudographics[:subplot_margin] do
    element.elements.each do |child|
      wr.vseparate
      weave_ctxt_plot_element child, fabric, wr,
          symbolism: symbolism
    end
  end
  wr.add_pseudographics :subplot_leadout
  wr.linebreak


<< Weave the section (ctxt) >>:
  # [[element.elements]] can be empty if a section
  # contains index anchor(s) but no content.  This is a
  # pathological case, to be sure, but it can happen, so
  # we'll need to check.
  rubricated = !element.elements.empty? &&
      element.elements[0].type == OL_RUBRIC

  << Weave the section's lead and set [[start_index]] (ctxt) >>

  << Weave the section's body from [[start_index]] on (ctxt) >>

  << Weave the section's top-level warnings (ctxt) >>


Weaving a section is a bit tricky, for we want to pretend that
both the section number, which is a field of an [[OL_SECTION]]
node, and the rubric (if any), which is optionally the first
child of it, comprise the section's title.  Furthermore,
following Knuth's practice, we'll want both to precede the first
regular paragraph, if any, without a separating paragraph break.

If the section has a rubric, we'll paint both the section number
and the rubric red (style [[:rubric]])  If there's no rubric,
the section number will be just bold ([[:section_number]], to be
precise).  This distinction corresponds to the Knuth's original
(C)WEB's practice of distinguishing 'starred sections' from
plain ones.

<< Weave the section's lead and set [[start_index]] (ctxt) >>:
  wr.vseparate
  start_index = 0 # index of the first non-special child
  << Output section number and, possibly, the rubric (ctxt) >>

  # If the rubric or the section sign is followed by a
  # paragraph, a chunk header, or a divert, we'll output
  # it in the same paragraph.
  starter = element.elements[start_index]
  if starter then
    case starter.type
    when OL_PARAGRAPH, OL_DIVERT, OL_CHUNK then
      wr.add_space
      weave_ctxt_section_part starter, fabric, wr,
          symbolism: symbolism
      start_index += 1
    else
      wr.linebreak
    end
  end

<< Output section number and, possibly, the rubric (ctxt) >>:
  if rubricated then
    start_index += 1
    wr.styled :rubric do
      wr.add_plain "%s%i." % [
        symbolism.section_prefix,
        element.section_number]
      wr.add_space
      wr.add_nodes element.elements.first.content,
          symbolism: symbolism
    end
  else
    wr.styled :section_number do
      wr.add_plain "%s%i." % [
        symbolism.section_prefix,
        element.section_number]
    end
  end

<< Weave the section's body from [[start_index]] on (ctxt) >>:
  element.elements[start_index .. -1].each do |child|
    wr.vseparate
    weave_ctxt_section_part child, fabric, wr,
        symbolism: symbolism
  end

. [[weave_ctxt_section_part]]

<< Other methods >>:
  def weave_ctxt_section_part element, fabric, wr,
      symbolism: default_symbolism
    case element.type
    << [[weave_ctxt_section_part]] rules >>
    else
      raise 'data structure error'
    end
    return
  end


<< [[weave_ctxt_section_part]] rules >>:

  when OL_PARAGRAPH then
    wr.add_nodes element.content, symbolism: symbolism
    wr.linebreak


  when OL_DIVERT, OL_CHUNK, OL_DIVERTED_CHUNK then
    if element.type & OLF_HAS_HEADER != 0 then
      weave_ctxt_chunk_header element, wr,
          symbolism: symbolism
      weave_ctxt_warning_list element.warnings, wr,
          inline: true
    end
    if element.type & OLF_HAS_CODE != 0 then
      << Weave the chunk's lines (ctxt) >>
      << ? Output the chain's finality marker >>
      weave_ctxt_warning_list element.warnings, wr,
          inline: true
      if element.final then
        wr.styled :chunk_xref do
          wr.add_nodes xref_chain(element, fabric,
                  symbolism: symbolism),
              symbolism: symbolism
        end
        wr.linebreak
      end
    end


  when OL_LIST then
    _weave_ctxt_list element.items, wr,
        symbolism: symbolism


  when OL_BLOCK then
    weave_ctxt_block element, wr


  when OL_BLOCKQUOTE then
    wr.add_plain '> '
    wr.hang wr.hangindent + 2, '>' do
      element.elements.each_with_index do |child, i|
        wr.linebreak unless i.zero?
        weave_ctxt_section_part child, fabric, wr,
            symbolism: symbolism
      end
    end


  when OL_THEMBREAK then
    (wr.width - wr.hangindent).times do
      wr.add_pseudographics :thematic_break_char
    end
    wr.linebreak


<< Weave the section's top-level warnings (ctxt) >>:
  unless (element.warnings || []).empty? then
    weave_ctxt_warning_list element.warnings, wr,
        inline: true, indent: false
  end


* Weaving code elements.

This method is good for both chunks with headers and diverts,
which in its regard, are just chunk headers.

<< Other methods >>:

. [[weave_ctxt_chunk_header]]

  def weave_ctxt_chunk_header element, wr,
      symbolism: default_symbolism
    wr.styled :chunk_header do
      wr.add_plain symbolism.chunk_name_delim.begin
      if element.root_type then
        wr.styled :root_type do
          wr.add_plain element.root_type
        end
        wr.add_space
      end
      wr.add_nodes Fabricator.parse_markup(element.name,
              PF_LINK),
          symbolism: symbolism
      if element.seq then
        wr.add_space
        wr.styled :seq_no do
          wr.add_plain '#'
          wr.add_plain element.seq.to_s
        end
      end
      wr.add_plain symbolism.chunk_name_delim.end
      wr.add_plain ":"
    end
    wr.linebreak
    return
  end


. [[weave_ctxt_block]]

  def weave_ctxt_block element, wr
    element.lines.each do |line|
      wr.styled :block_frame do
        wr.add_pseudographics :block_margin
      end
      wr.styled :monospace do
        wr.add_plain line
      end
      wr.linebreak
    end
    return
  end


<< Weave the chunk's lines (ctxt) >>:
  wr.styled :chunk_frame do
    wr.add_pseudographics element.initial ?
      :initial_chunk_margin :
      :chunk_margin
  end
  wr.styled :monospace do
    element.content.each do |node|
      case node.type
      when :verbatim then
        wr.add_plain node.data
      when :newline then
        wr.linebreak
        wr.styled :chunk_frame do
          wr.add_pseudographics :chunk_margin
        end
      when :use then
        weave_ctxt_use node, wr,
            symbolism: symbolism
      else raise 'data structure error'
      end
    end
  end
  wr.linebreak


. [[weave_ctxt_use]]

<< Other methods >>:
  def weave_ctxt_use node, wr,
      symbolism: default_symbolism
    wr.styled :use do
      wr.add_plain symbolism.chunk_name_delim.begin
      if node.clearindent then
        wr.add_plain ".clearindent "
      end
      wr.add_nodes Fabricator.parse_markup(node.name, PF_LINK),
          symbolism: symbolism
      if node.vertical_separation then
        wr.add_plain " " + node.vertical_separation
      end
      if node.postprocess then
        wr.add_plain " " + node.postprocess
      end
      wr.add_plain symbolism.chunk_name_delim.end
    end
    return
  end


<< ? Output the chain's finality marker >>:
  if element.final then
    wr.styled :chunk_frame do
      wr.add_pseudographics :final_chunk_marker
    end
    wr.linebreak
  end


. [[xref_chain]] (function)

<< Other methods >>:
  # Given a chunk, prepare its transclusion summary as a list of
  # markup nodes.  Should only be used on chunks that are the
  # last in a chunk chain (i.e., that have [[final]] set).
  def xref_chain element, fabric,
      dash: "-", # used to indicate ranges
      symbolism: default_symbolism,
      link_sections: false
    xref = markup
    if element.initial then
      xref.words "This chunk is "
    else
      xref.words "These chunks are "
    end
    << Summarise chunk's referrers into [[xref]] >>
    xref.words " and "
    << List chunk's tangled locations into [[xref]] >>
    return xref
  end

<< Summarise chunk's referrers into [[xref]] >>:
  cbn_entry = fabric.chunks_by_name[element.name]
  transcluders = cbn_entry.transcluders
  if transcluders then
    xref.words "transcluded by "
    xref.push *commatise_oxfordly(
        transcluders.map{|ref|
          m = markup
          m.node(MU_MENTION_CHUNK, name: ref.name)
          # [[ref.section_number]] can be [[nil]] if the
          # transcluder belongs to a unwoven fabric file as
          # unwoven sections are not numbered.
          unless ref.section_number.nil? then
            m.space.
                plain("(").
                node(MU_LINK,
                  content: markup.
                      plain(symbolism.section_prefix +
                          ref.section_number.to_s),
                  target: "#S.#{ref.section_number}",
                  implicit_face: true).
                plain(")")
          end
          m
        })
  else
    if cbn_entry.root_type then
      xref.words "solely a transclusion root"
    else
      xref.words "never transcluded"
    end
  end

<< List chunk's tangled locations into [[xref]] >>:
  tlocs = element.divert ?
      element.divert.chain_tangle_locs :
      element.tangle_locs
  if tlocs then
    xref.
        words("tangled to ").
        push(*commatise_oxfordly(
        tlocs.map{|range| markup.
            plain(format_location_range(range, dash: dash))
        })).
        plain(".")
  else
    xref.words "never tangled."
  end


This contraption generates lists with Oxford/Harvard-style
commas.  The input is a list of lists of markup nodes.  The
output is a single list (to be specific, a
[[Markup_Constructor]], which inherits from [[Array]]) of markup
nodes, with appropriate joiners interspersed.

. [[commatise_oxfordly]]

<< Other methods >>:
  def commatise_oxfordly items
    result = markup
    items.each_with_index do |item, i|
      unless i.zero? then
        unless items.length == 2 then
          result.plain ','
        end
        result.space
        if i == items.length - 1 then
          result.plain 'and'
          result.space
        end
      end
      result.push *item
    end
    return result
  end


* Weaving other narrative elements.

<< Weave the title (ctxt) >>:
  wr.styled :section_title do
    wr.vseparate 2
    wr.add_plain "#{element.number}."
    wr.add_space
    wr.hang do
      wr.add_nodes element.content, symbolism: symbolism
    end
  end
  wr.linebreak # line terminator


<< Other methods >>:

. [[_weave_ctxt_list]]

  def _weave_ctxt_list items, wr,
      symbolism: default_symbolism
    items.each do |item|
      wr.add_pseudographics :bullet
      wr.add_plain " "
      wr.hang do
        wr.add_nodes item.content, symbolism: symbolism
      end
      wr.linebreak
      unless (item.warnings || []).empty? then
        wr.hang do
          weave_ctxt_warning_list item.warnings, wr,
              inline: true
        end
      end
      if item.sublist then
        wr.add_plain "  "
        wr.hang do
          _weave_ctxt_list item.sublist.items, wr,
              symbolism: symbolism
        end
      end
    end
    return
  end


. [[weave_ctxt_toc]]

  def weave_ctxt_toc toc, wr,
      symbolism: default_symbolism
    if toc.length >= 2 then
      wr.vseparate 2
      wr.styled :section_title do
        wr.add_plain 'Contents'
      end
      wr.linebreak; wr.linebreak
      rubric_level = 0
      toc.each do |entry|
        << Weave the TOC entry (ctxt) >>
      end
    end
    return
  end


<< Weave the TOC entry (ctxt) >>:
  case entry.type
  when OL_TITLE then
    rubric_level = entry.level - 1 + 1
    wr.add_plain '  ' * (entry.level - 1)
    wr.add_plain entry.number + '.'
    wr.add_space
    wr.hang do
      wr.add_nodes entry.content, symbolism: symbolism
    end

  when OL_RUBRIC then
    wr.add_plain '  ' * rubric_level
    wr.add_plain '%s%i.' % [
      symbolism.section_prefix,
      entry.section_number]
    wr.add_space
    wr.hang do
      wr.add_nodes entry.content, symbolism: symbolism
    end

  else
    raise 'assertion failed'
  end
  wr.linebreak


* Weaving the index.

<< Weave index (ctxt) >>:
  wr.vseparate 2
  wr.styled :section_title do
    wr.add_plain 'Index'
  end
  wr.linebreak; wr.linebreak
  index = fabric.index
  index.keys.sort do |a, b|
    index[a].sort_key <=> index[b].sort_key
  end.each do |keyword|
    record = index[keyword]
    << Weave index record (ctxt) >>
  end


<< Weave index record (ctxt) >>:
  wr.add_nodes record.canonical_representation
  wr.hang 2 do
    record.refs.each_with_index do |(secno, reftype), i|
      wr.add_plain ',' unless i.zero?
      wr.add_space
      formatted_reference = _format_ctxt_index_ref secno,
          symbolism: symbolism
      << Weave index reference (ctxt) >>
    end
  end
  wr.linebreak

<< Weave index reference (ctxt) >>:
  case reftype
  when :manual then
    wr.add_plain formatted_reference

  when :definition then
    wr.styled :underscore do
      wr.add_plain formatted_reference
    end

  when :transclusion then
    wr.styled :italic do
      wr.add_plain formatted_reference
    end

  else
    raise 'assertion failed'
  end


. [[_format_ctxt_index_ref]]

<< Other methods >>:
  def _format_ctxt_index_ref target,
      symbolism: Fabricator.default_symbolism
    return case target
      when Integer then
        symbolism.section_prefix + target.to_s
      when Range then
        symbolism.section_prefix + target.begin.to_s +
            "-" +
            symbolism.section_prefix + target.end.to_s
      else
        raise 'type mismatch'
    end
  end


* The text wrapper.

We'll word-wrap the narrative (but not code) to a specified
output width using [[Text_Wrapper]].  It also accounts for the
escape sequences for colours, mainly by considering that their
width, for word-wrapping purposes, is zero.

. [[Text_Wrapper]]
. [[width]] (method of [[Text_Wrapper]])
. [[vsep]] (method of [[Text_Wrapper]])
. [[@vsep]] (slot of [[Text_Wrapper]])
. [[pseudographics]] (method of [[Text_Wrapper]])
. zero-one-many counting (of vertical separation)

<< in [[Fabricator]] >>:
  class Text_Wrapper
    attr_reader :width
    attr_accessor :vsep
    attr_reader :pseudographics

    def initialize port = $stdout,
        width: 80,
        pseudographics: UNICODE_PSEUDOGRAPHICS,
        palette: DEFAULT_PALETTE
      super()
      @port = port
      @width = width
      @pseudographics = pseudographics
      @palette = palette
      @hang = OpenStruct.new(
        content: '',
        width: 0)
      @curpos = 0
      # If [[@curspace]] is set or [[@curword.content]] is not
      # empty, we say the wrapper is in a /pending word/ state.
      # This is mutually exclusive with [[@pending_hang]].
      @curspace = nil
      @curword = OpenStruct.new(
        content: '',
        width: 0)
      # If [[@pending_hang]] is set, we say the wrapper is in a
      # /pending hang/ state.  In this state, nothing of the
      # current line has been output yet, but the indentation is
      # supposed to be output immediately before anything else
      # gets output, including a linebreak.  It is possible to
      # change [[@hang]] during this time.  This way, if the
      # thunk supplied to [[hang]] calls [[linebreak]]
      # immediately before returning, the line gets properly
      # broken, but the subsequent line will be prefixed with
      # the hang that was in effect outside this particular
      # [[hang]] call.
      @pending_hang = false
      @curmode = @palette.null
      # [[@vsep]] keeps track of consecutive blank lines.
      # Since we subscribe to zero-one-many counting, and the
      # amount of separation at the top of file is infinite,
      # we'll initialise it to 2.
      @vsep = 2
      return
    end

    << in [[Text_Wrapper]] >>
  end


<< in [[Text_Wrapper]] >>:

Process a series of 'word' characters.  Note that these do not
have to comprise a whole word; a word can be fed into the
[[Text_Wrapper]] using multiple consecutive [[add_plain]] calls.
All word characters, even whitespaces among them, are considered
nonbreakable.

. [[add_plain]] (method of [[Text_Wrapper]])
. [[@vsep]]

  def add_plain data
    _execute_pending_hang
    # Are we going to exceed [[@width]] with this addition?
    if @curspace and @curpos + data.length > @width then
      # yes, convert [[@curspace]] into a linebreak
      @port.puts @palette.null
      @port.print @hang.content
      @port.print @curmode
      @curspace = nil
      @curpos = @hang.width + @curword.width
    end
    @curword.content << data
    @curword.width += data.length
    @curpos += data.length

    # Since we're writing horizontally now, there's no vertical
    # separation anymore.  In fact, there's so little separation
    # that adding one linebreak would mean zero blank lines.
    @vsep = -1

    return
  end


Process a space character (or several, or zero).  This sets up a
permitted line break point.

. [[add_space]] (method of [[Text_Wrapper]])

  def add_space data = ' '
    _execute_pending_hang
    @port.print @curspace.content if @curspace
    @port.print @curword.content
    @curspace = OpenStruct.new(
      content: data,
      width: data.length)
    @curword = OpenStruct.new(
      content: '',
      width: 0)
    @curpos += data.length

    # Like with [[add_plain]], we'll clear [[@vsep]] here.
    @vsep = -1
    return
  end


Explicit linebreak.

. [[linebreak]] (method of [[Text_Wrapper]])

  def linebreak
    _execute_pending_hang
    @port.print @curspace.content if @curspace
    @port.print @curword.content
    @port.puts @palette.null
    @curspace = nil
    @curword = OpenStruct.new(
      content: '',
      width: 0)
    @curpos = 0
    @pending_hang = true
    @vsep += 1 unless @vsep >= 2
    return
  end


Conditional (possibly multiple) linebreaks for attaining at
least a given number of blank lines.

. [[vseparate]] (method of [[Text_Wrapper]])
. [[@vsep]]
. zero-one-many counting (of vertical separation)

  def vseparate amount = 1
    # In zero-one-many counting, we can't count any higher than
    # 'many'.
    raise 'too much separation needed' \
        unless amount <= 2
    while @vsep < amount do
      linebreak
    end
    return
  end


Pending hang resolution.

. [[_execute_pending_hang]]

  def _execute_pending_hang
    if @pending_hang then
      raise 'assertion failed' \
          if @curspace or !@curword.content.empty?
      @port.print @hang.content
      @curpos += @hang.width
      @port.print @curmode
      @pending_hang = false
    end
    return
  end
  private :_execute_pending_hang


Process a node, as generated by [[parse_markup]].

. [[add_node]] (method of [[Text_Wrapper]])

  def add_node node,
      symbolism: Fabricator.default_symbolism
    case node.type
    << [[case]] clauses of [[add_node]] >>
    else
      # Uh-oh, a bug: the parser has generated a node of a
      # type unknown to the weaver.
      raise 'invalid node type'
    end
    return
  end


Process a whole list of nodes.

. [[add_nodes]] (method of [[Text_Wrapper]])

  def add_nodes nodes,
      symbolism: Fabricator.default_symbolism
    nodes.each do |node|
      add_node node, symbolism: symbolism
    end
    return
  end


<< [[case]] clauses of [[add_node]] >>:

  when MU_PLAIN then
    add_plain node.data


  when MU_SPACE then
    add_space node.data || ' '


  when MU_SPECIAL_ATOM then
    case node.subtype
      when SA_NBSP then add_plain ' '
      when SA_NDASH then add_plain '-'
      when SA_MDASH then add_plain '--'
      when SA_ELLIPSIS then add_plain '...'
      else raise 'assertion faile'
    end


  when MU_BOLD, MU_ITALIC, MU_UNDERSCORE, MU_MONOSPACE then
    styled Fabricator::MARKUP2CTXT_STYLE[node.type] do
      add_nodes node.content, symbolism: symbolism
    end


. [[MARKUP2CTXT_STYLE]]

<< in [[Fabricator]] >>:
  MARKUP2CTXT_STYLE = { # node type tag => ctxt style name
    MU_BOLD => :bold,
    MU_ITALIC => :italic,
    MU_UNDERSCORE => :underscore,
    MU_MONOSPACE => :monospace,
  }


<< [[case]] clauses of [[add_node]] >>:

  when MU_MENTION_CHUNK then
    add_plain symbolism.chunk_name_delim.begin
    add_nodes Fabricator.parse_markup(node.name, PF_LINK),
        symbolism: symbolism
    add_plain symbolism.chunk_name_delim.end


  when MU_LINK then
    if node.implicit_face then
      styled :link do
        add_plain '<'
        add_nodes node.content, symbolism: symbolism
        add_plain '>'
      end
    else
      add_plain '<'
      add_nodes node.content, symbolism: symbolism
      unless node.implicit_face then
        add_space ' '
        styled :link do
          add_plain node.target
        end
      end
      add_plain '>'
    end


. hanging indentation
. indentation, hanging

Hanging indentation.  Used, for example, in the table of content
and in lists.  The content is to be fed into the
[[Text_Wrapper]] by the block supplied by the caller.
Optionally, the column to be used can be set explicitly.

<< in [[Text_Wrapper]] >>:

. [[hang]] (method of [[Text_Wrapper]])

  def hang column = nil, filler = ''
    # convert the preceding whitespace, if any, into 'hard'
    # space not subject to future wrapping
    if @curspace then
      @port.print @curspace.content
      @curspace = nil
    end

    prev_hang = @hang
    begin
      @hang = OpenStruct.new(width: column || @curpos)
      new_hang_width = @hang.width - prev_hang.width
      raise 'assertion failed: too much filler' \
          if filler.length > new_hang_width
      @hang.content = prev_hang.content +
          '%%-%is' % new_hang_width % filler
      yield
    ensure
      @hang = prev_hang
    end
    return
  end


. [[hangindent]] (method of [[Text_Wrapper]])

  def hangindent
    return @hang.width
  end


A region wrapped in an escape sequence.  The sequence is looked
up in [[@palette]], is treated as having zero width, and it gets
turned off (using the [[:null]] style) during linebreaks; see
[[add_plain]].  The region's content is to be fed into the
[[Text_Wrapper]] by the block supplied by the caller.

Note that [[styled]] calls can be nested, but only the innermost
style is restored after linebreaks.

. [[styled]] (method of [[Text_Wrapper]])
. [[@vsep]]

  def styled sequence_name
    _execute_pending_hang
    sequence = @palette[sequence_name]
    raise 'unknown palette entry' unless sequence
    prev_mode = @curmode
    begin
      @curmode = sequence
      @curword.content << sequence
      yield
    ensure
      @curmode = prev_mode
      @curword.content << prev_mode
      @vsep = -1
    end
    return
  end


* Pseudographics.

We'll mark code chunks with running vertical lines on the left,
with a turn at the head or tail to indicate whether this chunk
is initial or final in its chain.  This is best done using box
graphics, for which we'll use Unicode, but for archaic devices,
we'll also support plain ASCII box graphics.

<< in [[Fabricator]] >>:

. [[UNICODE_PSEUDOGRAPHICS]]

  UNICODE_PSEUDOGRAPHICS = OpenStruct.new(
    bullet: [0x2022].pack('U*'),
    initial_chunk_margin: [0x2500, 0x2510].pack('U*'),
    chunk_margin: [0x0020, 0x2502].pack('U*'),
    block_margin: "  ",
    final_chunk_marker:
        ([0x0020, 0x2514] + [0x2500] * 3).pack('U*'),
    thematic_break_char: [0x2500].pack('U*'),
    subplot_leadin: ([0x256D] + [0x2500] * 3).pack('U*'),
    subplot_margin: [0x2502, 0x0020].pack('U*'),
    subplot_leadout: ([0x2570] + [0x2500] * 3).pack('U*'),
  )


. [[ASCII_PSEUDOGRAPHICS]]

  ASCII_PSEUDOGRAPHICS = OpenStruct.new(
    bullet: "-",
    initial_chunk_margin: "+ ",
    chunk_margin: "| ",
    block_margin: "  ",
    final_chunk_marker: "----",
    thematic_break_char: "-",
    subplot_leadin: ",---",
    subplot_margin: "| ",
    subplot_leadout: "`---",
  )


As implied before, the default is Unicode.

<< Initialise [[$cmdline]] >>:
  $cmdline.pseudographics = Fabricator::UNICODE_PSEUDOGRAPHICS


Client code can output the pseudographics by this method.

. [[add_pseudographics]] (method of [[Text_Wrapper]])

<< in [[Text_Wrapper]] >>:
  def add_pseudographics name
    seq = @pseudographics[name]
    raise 'unknown pseudographics item' unless seq
    add_plain seq
    return
  end


* Palette.

<< in [[Fabricator]] >>:
  DEFAULT_PALETTE = OpenStruct.new(
    monospace: "\e[38;5;71m",
    bold: "\e[1m",
    italic: "\e[3m",
    underscore: "\e[4m",
    root_type: "\e[4m",
    seq_no: "\e[3m",
    chunk_frame: "\e[38;5;59m",
    block_frame: "",
    chunk_xref: "\e[38;5;59;3m",
    section_title: "\e[1;48;5;17m",
        # unspecified intense on dark blue background
    rubric: "\e[31;1m",
    section_number: "\e[0;1m",
    chunk_header: "\e[0;33;1m",
    use: "\e[34;1m",
    null: "\e[0m",
    inline_warning: "\e[31m",
    link: "\e[38;5;32m",
  )


=== HTML

* Overview.

First, let's take care of the I/O.

<< Weave [[fabric]] (HTML) >>:
  open filename, 'w' do |port|
    port.set_encoding 'utf-8'

    symbolism = $cmdline.symbolism.dup
    symbolism.chunk_name_delim ||=
        Fabricator.default_symbolism.chunk_name_delim

    Fabricator.weave_html fabric, port,
        title: $cmdline.fabric_filename,
        symbolism: symbolism,
        link_css: $cmdline.link_css
  end
  puts "Weaved #{filename}"


We'll keep the global parameters of an HTML weaving process in
an instance of [[HTML_Weaving]].

. [[HTML_Weaving]]

<< in [[Fabricator]] >>:
  class HTML_Weaving
    def initialize fabric, port,
        title: nil,
        symbolism: Fabricator.default_symbolism,
        link_css: [],
        link_processor: nil
      super()
      @fabric = fabric
      @port = port
      @title = title || "(Untitled)"
      @symbolism = symbolism
      @link_css = link_css
      @link_processor = link_processor
      return()
    end

    << in [[HTML_Weaving]] >>
  end


The process is shepherded by [[weave_html]].

. [[weave_html]]

<< Other methods >>:
  def weave_html fabric, port,
      title: nil,
      symbolism: default_symbolism,
      link_css: [],
      link_processor: nil
    weaving = Fabricator::HTML_Weaving.new fabric, port,
        title: title,
        symbolism: symbolism,
        link_css: link_css,
        link_processor: link_processor
    weaving.html
    return
  end


The next issue is the basic HTML structure.  We'll follow HTML 5
conventions.

<< in [[HTML_Weaving]] >>:

. [[html]] (method of [[HTML_Weaving]])

  def html
    @port.puts '<!doctype html>'
    @port.puts '<html>'
    html_head
    @port.puts '<body>'
    @port.puts '<main>'
    @port.puts "<h1>#{@title.to_xml}</h1>"
    << Weave fabric's warnings (HTML) >>
    html_presentation
    unless @fabric.index.empty? then
      html_index
    end
    @port.puts '</main>'
    @port.puts '</body>'
    @port.puts '</html>'
    return
  end


. [[html_head]] (method of [[HTML_Weaving]])

  def html_head
    @port.puts '<head>'
    @port.puts "<meta http-equiv='Content-type' " +
        "content='text/html; charset=utf-8' />"
    @port.puts "<title>#{@title.to_xml}</title>"
    if @link_css.empty? then
      @port.puts "<style type='text/css'>"
      @port.write File.read(
          File.join(Fabricator::RESOURCE_DIR, 'maui.css'))
      @port.puts "</style>"
    else
      @link_css.each do |link|
        @port.puts ("<link rel='stylesheet' " +
            "type='text/css' href='%s' />") % link.to_xml
      end
    end
    @port.puts '</head>'
    return
  end


. [[html_presentation]] (method of [[HTML_Weaving]])

  def html_presentation
    @fabric.presentation.each do |element|
      html_presentation_element element
      @port.puts
    end
    return
  end


. [[html_presentation_element]] (method of [[HTML_Weaving]])

  def html_presentation_element element
    case element.type
    when OL_TITLE then
      << Weave the title (HTML) >>
    when OL_SUBPLOT 
      << Weave the subplot (HTML) >>
    when OL_SECTION then
      << Weave the section (HTML) >>
    when OL_THEMBREAK then
      @port.puts "<hr />"
    when OL_NOP then
      # no operation
    when OL_IMPLICIT_TOC, OL_EXPLICIT_TOC then
      html_toc
    else raise 'data structure error'
    end
    return
  end


<< Weave the title (HTML) >>:
  @port.print '<h%i' % (element.level + 1)
  @port.print " id='%s'" % "T.#{element.number}"
  @port.print '>'
  @port.print "#{element.number}. "
  htmlify element.content
  @port.puts '</h%i>' % (element.level + 1)


. [[.maui-subplot]] (CSS class)

<< Weave the subplot (HTML) >>:
  @port.puts "<aside class='maui-subplot'>"
  element.elements.each_with_index do |element, i|
    @port.puts unless i.zero?
    html_presentation_element element
  end
  @port.puts '</aside>'


| . [[.maui-subplot]] (CSS class)
| << Sass rules >>:
|   .maui-subplot
|     border: solid 2px $subplot-frame
|     border-radius: 24px
|     padding-left: 12px
|     padding-right: 12px
|
|
| . [[$subplot-frame]] (Sass colour)
| << Sass colours >>:
|   // Darker than the edge of code chunks.
|   $subplot-frame: #888


. [[.maui-section]] (CSS class)

<< Weave the section (HTML) >>:
  rubricated = !element.elements.empty? &&
      element.elements[0].type == OL_RUBRIC
  start_index = 0
  @port.puts "<section class='maui-section' id='%s'>" %
      "S.#{element.section_number}"
  @port.puts
  << Weave the section's lead (HTML) >>
  @port.puts
  element.elements[start_index .. -1].each do |child|
    html_section_part child
    @port.puts
  end
  << Weave the section's top-level warnings, if any (HTML) >>
  @port.puts "</section>"

<< Weave the section's lead (HTML) >>:
  @port.print "<p>"
  << Weave section's number and rubric (HTML) >>
  subelement = element.elements[start_index]
  warnings = nil
  if subelement then
    case subelement.type
      when OL_PARAGRAPH then
        @port.print " "
        htmlify subelement.content
        start_index += 1
      when OL_DIVERT then
        @port.print " "
        html_chunk_header subelement, 'maui-divert',
            tag: 'span'
        warnings = subelement.warnings
        start_index += 1
      # FIXME: also support chunks here
    end
  end
  @port.puts "</p>"
  if warnings then
    html_warning_list warnings, inline: true
  end


. [[.maui-rubric]] (CSS class)
. [[.maui-section-number]] (CSS class)

<< Weave section's number and rubric (HTML) >>:
  @port.print "<b class='%s'>" %
      (rubricated ? 'maui-rubric' :
          'maui-section-number')
  @port.print @symbolism.section_prefix
  @port.print element.section_number
  @port.print "."
  if rubricated then
    @port.print " "
    htmlify element.elements[start_index].content
    start_index += 1
  end
  @port.print "</b>"


. [[html_section_part]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def html_section_part element
    case element.type
    << [[html_section_part]] rules >>
    else
      raise 'data structure error'
    end
    return
  end


<< [[html_section_part]] rules >>:

  when OL_PARAGRAPH then
    @port.print "<p>"
    htmlify element.content
    @port.puts "</p>"


  when OL_LIST then
    html_list element.items


  when OL_DIVERT then
    html_chunk_header element, 'maui-divert'
    @port.puts
    html_warning_list element.warnings, inline: true


. [[.maui-chunk]] (CSS class)
. [[.maui-initial-chunk]] (CSS class)
. [[.maui-final-chunk]] (CSS class)
. [[.maui-chunk-header]] (CSS class)
. [[.maui-chunk-xref]] (CSS class)

  when OL_CHUNK, OL_DIVERTED_CHUNK then
    @port.print "<div class='maui-chunk"
    @port.print " maui-initial-chunk" if element.initial
    @port.print " maui-final-chunk" if element.final
    @port.print "'>"
    if element.type == OL_CHUNK then
      html_chunk_header element, 'maui-chunk-header'
      @port.puts
    end
    html_chunk_body element
    unless (element.warnings || []).empty? then
      html_warning_list element.warnings, inline: true
    end
    if element.final then
      @port.print "<div class='maui-chunk-xref'>"
      htmlify(
          Fabricator.xref_chain(element, @fabric,
              symbolism: @symbolism,
              dash: "\u2013",
              link_sections: true))
      @port.puts "</div>"
    end
    @port.puts "</div>"


. [[.maui-block]] (CSS class)

  when OL_BLOCK then
    @port.print "<pre class='maui-block'>"
    element.lines.each_with_index do |line, i|
      @port.puts unless i.zero?
      @port.print line.to_xml
    end
    @port.puts "</pre>"


. [[.maui-blockquote]] (CSS class)

  when OL_BLOCKQUOTE then
    @port.print "<blockquote class='maui-blockquote'>"
    element.elements.each do |child|
      html_section_part child
      @port.puts
    end
    @port.puts "</blockquote>"

<< Sass rules >>:
  $blockquote_width: 4px
  .maui-blockquote
    margin-left: 0
    border-left: solid $blockquote_width #ddd
    padding-left: $chunk_indent


We'll also need to support a thematic break -- it doesn't
normally occur in sections but it may occur in blockquotes.

<< [[html_section_part]] rules >>:
  when OL_THEMBREAK then
    @port.puts "<hr />"


As in the coloured text output, the table of content takes a
general form of a tree.  However, HTML permits a new feature we
can't offer in non-hyper text: we're going to make each entry
into a local link, either in the [[#T.foo]] form for titles or
[[#S.foo]] form for sections.

. [[html_toc]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def html_toc
    if @fabric.toc.length >= 2 then
      @port.puts "<h2>Contents</h2>"
      last_level = 0
      # What level should the rubrics in the current
      # (sub(sub))chapter appear at?
      rubric_level = 1
      @fabric.toc.each do |entry|
        if entry.type == OL_RUBRIC then
          level = rubric_level
        else
          level = entry.level
          rubric_level = entry.level + 1
        end
        << Generate [[ul]]/[[li]] tags to match [[level]] >>
        << Weave the TOC entry (HTML) >>
        last_level = level
      end
      @port.puts "</li></ul>" * last_level
    end
    return
  end

<< Generate [[ul]]/[[li]] tags to match [[level]] >>:
  if level > last_level then
    raise 'assertion failed' \
        unless level == last_level + 1
    @port.print "\n<ul><li>"
  elsif level == last_level then
    @port.print "</li>\n<li>"
  else
    @port.print "</li></ul>" * (last_level - level) +
        "\n<li>"
  end

<< Weave the TOC entry (HTML) >>:
  case entry.type
  when OL_TITLE then
    @port.print "#{entry.number}. "
    @port.print "<a href='#T.#{entry.number}'>"
    htmlify entry.content
    @port.print "</a>"
  when OL_RUBRIC then
    @port.print @symbolism.section_prefix
    @port.print entry.section_number
    @port.print ". "
    @port.print "<a href='#S.#{entry.section_number}'>"
    htmlify entry.content
    @port.print "</a>"
  else
    raise 'assertion failed'
  end

. [[html_list]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def html_list items
    @port.puts "<ul>"
    items.each do |item|
      @port.print "<li>"
      htmlify item.content
      if item.sublist then
        @port.puts
        html_list item.sublist.items
      end
      unless (item.warnings || []).empty? then
        @port.puts
        html_warning_list item.warnings, inline: true
      end
      @port.puts "</li>"
    end
    @port.puts "</ul>"
    return
  end


<< in [[HTML_Weaving]] >>:

. [[html_chunk_header]] (method of [[HTML_Weaving]])

  def html_chunk_header element, cls, tag: 'div'
    @port.print "<#{tag} class='%s'>" % cls.to_xml
    @port.print @symbolism.chunk_name_delim.begin
    if element.root_type then
      @port.print "<u>%s</u> " % element.root_type.to_xml
    end
    htmlify Fabricator.parse_markup(element.name, PF_LINK)
    if element.seq then
      @port.print " "
      @port.print "<span class='maui-chunk-seq'>"
      @port.print "#"
      @port.print element.seq.to_s
      @port.print "</span>"
    end
    @port.print @symbolism.chunk_name_delim.end + ":"
    @port.print "</#{tag}>"
    # Note that we won't output a trailing linebreak here.
    return
  end


. [[html_chunk_body]] (method of [[HTML_Weaving]])
. [[.maui-chunk-body]] (CSS class)

  def html_chunk_body element
    @port.print "<pre class='maui-chunk-body'>"
    element.content.each do |node|
      case node.type
      when :verbatim then
        @port.print node.data.to_xml
      when :newline then
        @port.puts
      when :use then
        << Weave the [[use]] node (HTML) >>
      else raise 'data structure error'
      end
    end
    @port.puts "</pre>"
    return
  end

. [[.maui-transclude]] (CSS class)

<< Weave the [[use]] node (HTML) >>:
  @port.print "<span class='maui-transclude'>"
  @port.print @symbolism.chunk_name_delim.begin
  if node.clearindent then
    @port.print ".clearindent "
  end
  htmlify Fabricator.parse_markup(node.name, PF_LINK)
  if node.vertical_separation then
    @port.print " " + node.vertical_separation.to_xml
  end
  if node.postprocess then
    @port.print " " + node.postprocess.to_xml
  end
  @port.print @symbolism.chunk_name_delim.end
  @port.print "</span>"


* Displaying warnings in HTML.

<< Weave the section's top-level warnings, if any (HTML) >>:
  unless (element.warnings || []).empty? then
    html_warning_list element.warnings, inline: true
    @port.puts
  end

<< Weave fabric's warnings (HTML) >>:
  unless @fabric.warnings.empty? then
    @port.puts "<h2>Warnings</h2>"
    @port.puts
    html_warning_list @fabric.warnings
    @port.puts
  end

. [[html_warning_list]]
. [[.maui-warnings]] (CSS class)
. [[.maui-inline-warnings]] (CSS class)

<< in [[HTML_Weaving]] >>:
  def html_warning_list list, inline: false
    if list and !list.empty? then
      @port.print "<ul class='maui-warnings"
      @port.print " maui-inline-warnings" if inline
      @port.puts "'>"
      list.each do |warning|
        @port.print "<li"
        @port.print " id='W.#{warning.number}'" if inline
        @port.print ">"
        @port.print "!!! " if inline
        if !inline and warning.inline then
          @port.print "<a href='#W.%i'>" % warning.number
        end
        @port.print "<tt>%s</tt>" %
            Fabricator.format_location(warning.loc).to_xml
        @port.print ": " + warning.message
        @port.print "</a>" if !inline and warning.inline
        @port.puts "</li>"
      end
      @port.puts "</ul>"
    end
    return
  end


* Generating the index in HTML.

. [[html_index]] (method of [[HTML_Weaving]])
. [[#maui-index]] (CSS identifier)

<< in [[HTML_Weaving]] >>:

  def html_index
    @port.puts "<h2>Index</h2>"
    @port.puts
    @port.puts "<nav id='maui-index'>"
    @port.puts "<ul>"
    index = @fabric.index
    index.keys.sort do |a, b|
      index[a].sort_key <=> index[b].sort_key
    end.each do |keyword|
      record = index[keyword]
      @port.print "<li>"
      htmlify record.canonical_representation
      @port.print " "
      record.refs.each_with_index do |(secno, reftype), i|
        @port.print ',' unless i.zero?
        @port.print ' '
        html_index_reference secno, reftype
      end
      @port.puts "</li>"
    end
    @port.puts "</ul>"
    @port.puts "</nav>"
    return
  end


. [[.maui-index-manual]] (CSS class)
. [[.maui-index-definition]] (CSS class)
. [[.maui-index-transclusion]] (CSS class)

  def html_index_reference secno, reftype
    @port.print "<span class='maui-index-#{reftype}'>"
    case secno
      when Integer then
        @port.print "<a href='#S.#{secno}'>"
        @port.print @symbolism.section_prefix
        @port.print secno
        @port.print "</a>"
      when Range then
        # The hyperlink will reference only the very first
        # section in the range, but we'll mark the whole
        # range up as a link for cosmetic reasons.
        @port.print "<a href='#S.#{secno.begin}'>"
        @port.print @symbolism.section_prefix
        @port.print secno.begin
        @port.print "\u2013"
        @port.print @symbolism.section_prefix
        @port.print secno.end
        @port.print "</a>"
      else
        raise 'assertion failed'
    end
    @port.print "</span>"
    return
  end


. [[.maui-index-manual]] (CSS class)
. [[.maui-index-definition]] (CSS class)
. [[.maui-index-transclusion]] (CSS class)

<< Sass rules >>:
  // .maui-index-manual does not need any rules

  .maui-index-definition
    text-decoration: underline

  .maui-index-transclusion
    font-style: italic


* Conversion of a horizontal markup tree to HTML.

. [[htmlify]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def htmlify nodes
    nodes.each do |node|
      case node.type
      << [[case]] clauses of [[htmlify]] >>
      else
        raise 'invalid node type'
      end
    end
    return
  end


<< [[case]] clauses of [[htmlify]] >>:

  when MU_PLAIN then
    @port.print node.data.to_xml


  when MU_SPACE then
    @port.print((node.data || ' ').to_xml)


  when MU_SPECIAL_ATOM then
    case node.subtype
      when SA_NBSP then @port.print '&nbsp;'
      when SA_NDASH then @port.print '&ndash;'
      when SA_MDASH then @port.print '&mdash;'
      when SA_ELLIPSIS then @port.print '&hellip;'
      else raise 'assertion failed'
    end


  when MU_BOLD, MU_ITALIC, MU_UNDERSCORE,
      MU_MONOSPACE then
    html_tag = Fabricator::MARKUP2HTML[node.type]
    @port.print "<%s>" % html_tag
    htmlify node.content
    @port.print "</%s>" % html_tag


. [[MARKUP2HTML]]

<< in [[Fabricator]] >>:
  MARKUP2HTML = { # node type tag => HTML tag
    MU_MONOSPACE => 'code',
    MU_BOLD => 'b',
    MU_ITALIC => 'i',
    MU_UNDERSCORE => 'u',
  }


<< [[case]] clauses of [[htmlify]] >>:

. [[.maui-chunk-mention]] (CSS class)

  when MU_MENTION_CHUNK then
    @port.print "<span class='maui-chunk-mention'>"
    @port.print @symbolism.chunk_name_delim.begin
    htmlify Fabricator.parse_markup(node.name, PF_LINK)
    @port.print @symbolism.chunk_name_delim.end
    @port.print "</span>"


  when MU_LINK then
    target = node.target
    if @link_processor then
      target, *classes = @link_processor.call target
    else
      classes = []
    end
    @port.print "<a href='#{target.to_xml}'"
    unless classes.empty? then
      @port.print " class='#{classes.join(' ').to_xml}'"
    end
    @port.print ">"
    htmlify node.content
    @port.print "</a>"


* XML escaping.

<< Outer definitions >>:
  class ::String
    # Local enclosed variable for [[#to_xml]]
    char_entities = {
      '&' => '&amp;',
      '<' => '&lt;',
      '>' => '&gt;',
      '"' => '&quot;',
      "'" => '&apos;',
    }.freeze

    define_method :to_xml do ||
      return gsub(/[&<>'"]/){char_entities[$&]}
    end
  end


* The built-in stylesheet.

Our built-in stylesheet has been written in Sass.  Maui runs it
through the Sass translator to get plain CSS at tangling time.

<< .file res/maui.css >>:
  << res/maui.sass |sass->css >>


<< .file res/maui.sass >>:
  /* * * *   Fonts   * * * */
  << Sass [[@import]] clauses for Google fonts >>

  // * * * * Dimensions
  << Sass dimensions >>

  // * * * * Colours
  << Sass colours >>

  /* * * *   Rules   * * * */
  << Sass rules >>


Maui's HTML-woven output uses two font families: a 'plain text'
one for most of the narrative and a 'monospaced' one for actual
code.  We have chosen Roboto for the former and Cousine for the
latter.

<< Sass [[@import]] clauses for Google fonts >>:
  $fontsrc: "http://fonts.googleapis.com/css?family="
  $fontvariants: "400,400italic,700,700italic"
  @import url("#{$fontsrc}Roboto:#{$fontvariants}")
  @import url("#{$fontsrc}Cousine:#{$fontvariants}")

. [[.maui-transclude]] (CSS class)

<< Sass rules >>:
  body, .maui-transclude
    font-family: "Roboto", sans-serif

  pre, tt, code
    font-family: "Cousine", monospace


The main text for Maui's output will be black on white.

<< Sass colours >>:
  $main-foreground: black
  $main-background: white

<< Sass rules >>:
  body
    colour: $main-foreground
    background: $main-background


Furthermore, when monospaced text appears in narrative (as
contrary to code chunks), we'll dye it green for extra
highlighting.

<< Sass colours >>:
  $narrative-monospaced-colour: forestgreen

<< Sass rules >>:
  tt, code
    color: $narrative-monospaced-colour


Inline warnings we'll paint bright red for high visibility.
(Note that the class' name is in plural --- a single HTML
element can contain multiple warnings.)

<< Sass colours >>:
  $inline-warning-colour: red

. [[.maui-inline-warnings]] (CSS class)

<< Sass rules >>:
  .maui-inline-warnings
    color: $inline-warning-colour


The rules so far have a conflict.  What happens when a [[tt]]
element appears inside an inline warning?  Left alone, they
would become green.  However, in this context, we'll want them
red.

. [[.maui-warnings]] (CSS class)

<< Sass rules >>:
  .maui-warnings tt
    color: inherit


By medieval tradition, rubrics should be red.  We'll use a
slightly darker shade and go with what CSS calls [[crimson]]
instead of [[red]].

<< Sass colours >>:
  $rubric-colour: crimson

. [[.maui-rubric]] (CSS class)

<< Sass rules >>:
  .maui-rubric
    color: $rubric-colour


Maui outputs warnings in unordered lists, but we don't actually
want bullets in front of them.

. [[.maui-warnings]] (CSS class)

<< Sass rules >>:
  ul.maui-warnings
    padding-left: 0
    > li
      list-style: none


Let us now proceed to styling the code chunks themselves.
First, the rules:

<< Sass colours >>:
  $chunk-rule-colour: #cccccc

<< Sass dimensions >>:
  $chunk-indent: 20px
  $chunk-rule: 2px
  $chunk-rule-sep: 5px
  $final-chunk-rule-length: 40px

. [[.maui-chunk-body]] (CSS class)
. [[.maui-initial-chunk]] (CSS class)
. [[.maui-final-chunk]] (CSS class)

<< Sass rules >>:
  .maui-chunk-body
    margin-left: $chunk-indent
    border-left: $chunk-rule solid $chunk-rule-colour
    padding-left: $chunk-rule-sep

  .maui-initial-chunk>.maui-chunk-body:before
    content: ""
    display: block
    width: $chunk-indent + $chunk-rule
    border-top: solid $chunk-rule $chunk-rule-colour
    margin-left: - $chunk-indent - $chunk-rule - $chunk-rule-sep

  .maui-final-chunk>.maui-chunk-body:after
    content: ""
    display: block
    margin-left: - $chunk-rule - $chunk-rule-sep
    width: $final-chunk-rule-length
    border-bottom: solid $chunk-rule $chunk-rule-colour


A chunk's body shall have zero vertical margins; its containing
[[maui-chunk]] will take care of vertical separation.  This also
applies to the block of warnings inside a chunk.

<< Sass dimensions >>:
  $paragraph-sep: 16px

. [[.maui-chunk-body]] (CSS class)
. [[.maui-chunk]] (CSS class)
. [[.maui-warnings]] (CSS class)

<< Sass rules >>:

  .maui-chunk-body, .maui-chunk>.maui-warnings
    margin-top: 0
    margin-bottom: 0

  .maui-chunk
    margin-top: $paragraph-sep
    margin-bottom: $paragraph-sep


The cross-references following (final) chunks are smaller and in
italic for reduced obtrusivity, and they align with the chunk's
vertical rule but are deliberately slightly off from aligning
with the code inside the chunk.

. [[.maui-chunk-xref]] (CSS class)

  .maui-chunk-xref
    font-size: small
    font-style: italic
    margin-left: $chunk-indent + $chunk-rule


We'll apply the same left indentation to sample code blocks as
to chunks, except without the running vertical rule.

. [[.maui-block]] (CSS class)

  .maui-block
    margin-left: $chunk-indent + $chunk-rule + $chunk-rule-sep


Finally, this rule tells pre-HTML5 browsers that [[main]],
[[article]], [[aside]], and [[section]] are [[div]]-like, not
[[span]]-like:

<< Sass rules >>:
  /* Backwards compatibility with pre-HTML5 browsers */
  main, article, aside, section
    display: block


=== Symbolism

Several of the symbols Maui uses in its woven representation of
fabrics are customisable.  To that end, many weaving subroutines
accept, and pass on, [[OpenStruct]] instances with the preferred
symbols.  Here are the defaults.

. [[default_symbolism]]

<< Other methods >>:
  def default_symbolism
    return OpenStruct.new(
        section_prefix: "§",
        # Two endpoints are stored in a [[Range]].
        chunk_name_delim: "\u00AB" .. "\u00BB")
  end


== The skeletal composition of the library

. [[Fabricator]] (top-level module)

<< .file lib/mau/fabricator.rb >>:
  # encoding: UTF-8

  require 'ostruct'
  require 'rbconfig'
  require 'set'
  require 'stringio'

  << Outer definitions >>

  module Fabricator
    RESOURCE_DIR = File.expand_path '../../res',
        File.dirname(__FILE__)
    << in [[Fabricator]] >>
  end

  class << Fabricator
    include Fabricator
    << Other methods >>
  end


== The command line interface

<< .script bin/maui >>:
  #! /usr/bin/ruby -rubygems
  # encoding: UTF-8

  require 'getoptlong'
  require 'mau/fabricator'

  $0 = 'maui' # for [[GetoptLong]] error reporting
  << Parse command line >>

  fabric = open $cmdline.fabric_filename, 'r' do |port|
    Fabricator.load_fabric port,
        chunk_size_limit: $cmdline.chunk_size_limit,
        bases: $cmdline.bases
  end

  << Set up the [[writeout_plan]] >>

  Fabricator.show_warnings fabric

  << Execute the [[writeout_plan]] >>


<< Set up the [[writeout_plan]] >>:
  writeout_plan = {}
  << Plan to write out tangling results >>
  << Plan to write out specially generated files >>


<< Plan to write out tangling results >>:
  fabric.tangles.each_value do |results|
    writeout_plan[results.filename] =
        Fabricator.plan_to_write_out(results)
  end


<< Plan to write out specially generated files >>:
  [
    << Special out-writables >>
  ].each do |special|
    filename = File.basename($cmdline.fabric_filename).
        sub(/(\.fab)?$/i, special.suffix)
    if writeout_plan.has_key? filename then
      number = fabric.warnings.length + 1
      first_header = fabric.chunks_by_name[filename].
          headers.first
      warning = OpenStruct.new(
        loc: first_header.header_loc,
        message: "name clash with #{special.description}",
        number: number,
        inline: true,
      )
      fabric.warnings.push warning
      (first_header.warnings ||= []).push warning
      # For ordering purposes, we'll delete the old value before
      # adding the new one at the same key.
      writeout_plan.delete filename
    end
    writeout_plan[filename] = special.generator
  end


<< Special out-writables >>:

  OpenStruct.new(
    suffix: '.html',
    description: 'HTML weaving',
    generator: proc do |filename|
      << Weave [[fabric]] (HTML) >>
    end,
  ),


  OpenStruct.new(
    suffix: '.ctxt',
    description: 'ctxt weaving',
    generator: proc do |filename|
      << Weave [[fabric]] (ctxt) >>
    end,
  ),


<< Execute the [[writeout_plan]] >>:
  exit_code = 0
  (ARGV.empty? ? writeout_plan.keys : ARGV.uniq).
      each do |filename|
    if thunk = writeout_plan[filename] then
      path = filename.split '/'
      (0 .. path.length - 2).each do |i|
        dirname = path[0 .. i].join '/'
        begin
          Dir.mkdir dirname
          puts "Created directory #{dirname}"
        rescue Errno::EEXIST
        end
      end
      thunk.call filename
    else
      $stderr.puts "maui: #{filename}: unknown output file"
      exit_code = 1
    end
  end
  exit exit_code


== Rubygem metadata

<< .file maui.gemspec >>:
  # This file is tangled from [[maui.fab]].
  # Please do not edit directly.

  Gem::Specification.new do |s|
    s.name = 'maui'
    s.version = '<< VERSION >>'
    s.date = '2014-09-23'
    s.homepage = 'https://github.com/digwuren/maui'
    s.summary = 'A wiki-style literate programming engine'
    s.author = 'Andres Soolo'
    s.email = 'dig@mirky.net'
    s.files = File.read('Manifest.txt').split(/\n/)
    s.executables << 'maui'
    s.license = 'GPL-3'
    s.description = <<EOD
  Fabricator is a literate programming engine with wiki-like
  notation.  Mau is a PIM-oriented wiki engine built around
  Fabricator.  This gem contains Maui, the Mau Independent
  Fabricator, allowing Fabricator to be used via a command line
  interface or via the Ruby API without a need to employ a full
  installation of Mau.
  EOD
    s.has_rdoc = false
  end

<< .file Manifest.txt >>:
  GPL-3
  Makefile
  Manifest.txt
  README.fab
  README.html
  bin/maui
  lib/mau/fabricator.rb
  res/maui.css
  res/maui.sass
  maui.fab
  maui.gemspec


* The command line parser.

<< Parse command line >>:
  begin
    << Parse command line options >>
    << Parse command line arguments >>
  rescue GetoptLong::Error => e
    # no need to display; it has already been reported
    exit 1
  end

<< Parse command line options >>:
  $cmdline = OpenStruct.new
  << Initialise [[$cmdline]] .dense >>

  GetoptLong.new(
      << Option declarations .dense >>
      ).each do |opt, arg|
    case opt
    << Command line option handlers >>
    else
      raise 'assertion failed'
    end
  end


<< Initialise [[$cmdline]] >>:
  $cmdline.symbolism = OpenStruct.new(section_prefix: "§")


. [[--base]]

<< Option summary >>:
  --base=FILENAME
      Load fabric base from this file.  Code defined there will
      be tangled together with the main fabric, but not woven.

<< Option declarations >>:
  ['--base', '-b', GetoptLong::REQUIRED_ARGUMENT],

<< Initialise [[$cmdline]] >>:
  $cmdline.bases = []

<< Command line option handlers >>:
  when '--base' then
    $cmdline.bases.push arg


. [[--section-prefix]]

<< Option summary >>:
  --section-prefix=STRING
      Use this string rather than § as the section prefix.

<< Option declarations >>:
  ['--section-prefix', GetoptLong::REQUIRED_ARGUMENT],

<< Command line option handlers >>:
  when '--section-prefix' then
    $cmdline.symbolism.section_prefix = arg


. [[--chunk-name-delim]]

<< Option summary >>:
  --chunk-name-delim=BEFORE,AFTER
      Use these strings around chunks' names.

<< Option declarations >>:
  ['--chunk-name-delim', GetoptLong::REQUIRED_ARGUMENT],

<< Command line option handlers >>:
  when '--chunk-name-delim' then
    before, after = arg.split ',', 2
    unless after then
      $stderr.puts "maui: " +
          "--chunk-name-delim requires two strings"
      exit 1
    end
    $cmdline.symbolism.chunk_name_delim = before .. after


. [[--output-width]]

<< Option summary >>:
  --output-width=N
      Word-wrap the woven ctxt at this width.

<< Option declarations >>:
  ['--output-width', GetoptLong::REQUIRED_ARGUMENT],

<< Initialise [[$cmdline]] >>:
  $cmdline.output_width = 80

<< Command line option handlers >>:
  when '--output-width' then
    unless arg =~ /\A\d+\Z/ then
      $stderr.puts "maui: --output-width requires a number"
      exit 1
    end
    $cmdline.output_width = arg.to_i


Chunks longer than this many lines will be dubbed 'long' by a
warning.  If longer than twice this many lines, 'very long'.
Zero disables this check.

. [[--chunk-size-limit]]

<< Option summary >>:
  --chunk-size-limit=LINE-COUNT
      Consider chunks longer than this many lines warnably long.
      Chunks longer than twice this many lines will be
      considered warnably very long.

<< Option declarations >>:
  ['--chunk-size-limit', GetoptLong::REQUIRED_ARGUMENT],

<< Initialise [[$cmdline]] >>:
  $cmdline.chunk_size_limit = 24

<< Command line option handlers >>:
  when '--chunk-size-limit' then
    unless arg =~ /\A\d+\Z/ then
      $stderr.puts "maui: --chunk-size-limit " +
          "requires a number"
      exit 1
    end
    arg = arg.to_i
    arg = nil if arg <= 0
    $cmdline.chunk_size_limit = arg


For HTML output, the [[--link-css]] option permits the user to
specify one or more stylesheets that should be applied to the
result.

. [[--link-css]]

<< Option summary >>:
  --link-css=URL
      Specify a stylesheet to be applied to the woven HTML.
      Availability of the target CSS to the browser and the
      relativity of the link are user's responsibility.  If used
      multiple times, all these links will be used, and their
      order is preserved.

      Usage of this option suppresses including the default,
      built-in stylesheet in the output.

<< Option declarations >>:
  ['--link-css', GetoptLong::REQUIRED_ARGUMENT],

<< Initialise [[$cmdline]] >>:
  $cmdline.link_css = []

<< Command line option handlers >>:
  when '--link-css' then
    $cmdline.link_css.push arg


<< Parse command line arguments >>:
  if ARGV.empty? then
    $stderr.puts "maui: no fabric filename given"
    exit 1
  end
  if ARGV.first.start_with? '+' then
    $stderr.puts "maui: the main fabric must not be an add-on"
    exit 1
  end
  $cmdline.fabric_filename = ARGV.shift


. [[--unicode-boxes]]

<< Command line option handlers >>:
  when '--unicode-boxes' then
    $cmdline.pseudographics =
        Fabricator::UNICODE_PSEUDOGRAPHICS

<< Option declarations >>:
  ['--unicode-boxes', GetoptLong::NO_ARGUMENT],


. [[--ascii-boxes]]

<< Command line option handlers >>:
  when '--ascii-boxes' then
    $cmdline.pseudographics = Fabricator::ASCII_PSEUDOGRAPHICS

<< Option declarations >>:
  ['--ascii-boxes', GetoptLong::NO_ARGUMENT],


Finally, the GNU Coding Standards recommend implementing
[[--help]] and [[--version]].

. [[--help]]

<< Option summary >>:
  --help
      Print this usage.

<< Option declarations >>:
  ['--help', GetoptLong::NO_ARGUMENT],

<< Command line option handlers >>:
  when '--help' then
    puts "<< .clearindent Usage help >>"
    puts
    exit 0


<< Usage help >>:
  Usage: maui [options] fabric-file

  Process the given Mau fabric, tangle its files and weave its
  narrative into both HTML and coloured text.

  << Option summary >>

  Report bugs to: <dig@mirky.net>


. [[--version]]

<< Option summary >>:
  --version
      Show version data.

<< Option declarations >>:
  ['--version', GetoptLong::NO_ARGUMENT],

<< Command line option handlers >>:
  when '--version' then
    puts "<< .clearindent [[--version]] output >>"
    puts
    exit 0

<< [[--version]] output >>:
  << IDENT >>
  Copyright (C) 2003-2014 Andres Soolo
  Copyright (C) 2013-2014 Knitten Development Ltd.

  Licensed under GPLv3+: GNU GPL version 3 or later
    <http://gnu.org/licenses/gpl.html>

  This is free software: you are free to change and
  redistribute it.

  There is NO WARRANTY, to the extent permitted by law.


== Implicit TOC place determination

We'll want an [[OL_IMPLICIT_TOC]] node just before the first
node in the main plot that contains [[OL_TITLE]] (which must be
in the main plot itself) or [[OL_RUBRIC]] (which is inside an
[[OL_SECTION]] and perhaps an [[OL_SUBPLOT]] or several).  We
do this by:
- adding an [[OL_NOP]] node to the main plot just before adding
  an [[OL_TITLE]], [[OL_SUBPLOT]], or [[OL_SECTION]] node
  directly to it, unless we have already found the place for the
  implicit TOC;
- saving a pointer to [[OL_NOP]] node in [[@toc_candidate]];
- and upgrading [[@toc_candidate]] to [[OL_IMPLICIT_TOC]] upon
  integrating the first [[OL_TITLE]] or [[OL_RUBRIC]] node.

<< Initialise slots of [[Integrator]] >>:
  @toc_candidate = nil


<< ? Generate a candidate [[OL_IMPLICIT_TOC]] node >>:
  if !suppress_narrative and
      [OL_TITLE, OL_SUBPLOT, OL_SECTION].include?(
          element.type) and
      @subplot.nil? and
      (@toc_candidate.nil? or
          @toc_candidate.type == OL_NOP) then
    @toc_candidate = OpenStruct.new type: OL_NOP
    @output.presentation.push @toc_candidate
  end


<< ? Upgrade [[@toc_candidate]] >>:
  # If this is the first TOC entry, promote our TOC candidate
  # into the actual place for implicit TOC
  if @toc_candidate.type == OL_NOP then
    @toc_candidate.type = OL_IMPLICIT_TOC
  end
