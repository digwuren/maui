This is Mau Independent Fabricator, a standalone literate
programming tool with wiki-like notation.

<< IDENT >>:
  Mau Independent Fabricator << VERSION >>

<< VERSION >>:
  3.1.0


== Parsing

* Parser's front-end.

For the parser, [[input]] will be an open [[IO]] instance.  For
parsing ease (most crucially, in order to support blank lines in
chunks and indented blocks), we'll wrap it into a
[[Vertical_Peeker]].  The parser will generate [[OpenStruct]]
instances for vertical elements extracted from the input, in
order, and feed them into [[Integrator]] that will take care of
establishing a proper document tree, collecting the chunks for
later tangling, and preparing the cross-references.

<< Parse fabric from [[input]] >>:

  vp = Fabricator::Vertical_Peeker.new input
  integrator = Fabricator::Integrator.new


. space-dash-space ambiguity
The Mau notation has an ambiguity: a line starting with
whitespace, dash, and whitespace can start an indented block but
it can also start a bulleted list's item.  In order to resolve
the ambiguity, we'll require that top-level bullet lists be
unindented, and indented bullet items can only appear if a
higher-level list has already been established.

  parser_state = OpenStruct.new(
      vertical_separation: nil,
          # the number of blank lines immediately preceding
          # the element currently being parsed
  )
  loop do
    << Pass and count blank lines >>
    break if vp.eof?
    << Handle explicit section break >>
    element_location = vp.location_ahead
    case vp.peek_line
    << Vertical elements' parsing rules >>
    else raise 'assertion failed'
    end
    integrator.integrate element
  end
  << Handle the end of fabric >>
  integrator.check_chunk_sizes(chunk_size_limit)


. "more than two consecutive blank lines" (warning)

<< Pass and count blank lines >>:
  parser_state.vertical_separation = 0
  while vp.peek_line == '' do
    if parser_state.vertical_separation == 2 then
      integrator.warn vp.location_ahead,
          "more than two consecutive blank lines"
    end
    parser_state.vertical_separation += 1
    vp.get_line
  end


<< Vertical elements' parsing rules >>:
  when /^\s+/ then
    if !integrator.in_list? or
        vp.peek_line !~ /^
            (?<margin> \s+ )
            - (?<separator> \s+ )
            /x then
      << Parse indented block >>
    else
      << Parse deep bullet >>
    end


What looks to us like an indented block may need to be upgraded
into a chunk by the integrator.  Our parser does not know
whether this is the case because it does not keep track of
diversions.  Since location data is needed for chunks, we'll
record it, even if it might not be useful for ordinary indented
blocks.

<< Parse indented block >>:
  body_location = vp.location_ahead
  element = vp.get_indented_lines_with_skip
  element.type = OL_BLOCK
  element.body_loc = element_location


. [[get_indented_lines_with_skip]]

<< in [[Vertical_Peeker]] >>:
  def get_indented_lines_with_skip
    indent = nil; lines = []
    while peek_line =~ /^\s+/ or
        (peek_line == '' and
         !lines.empty? and
         peek_line(1) =~ /^\s+/) do
      # If the line ahead is not indented but we passed the
      # test, then [[get_line]] will return [[""]] and [[$&]]
      # is the _following_ line's indentation.
      indent = $&.length if indent.nil? or $&.length < indent
      lines.push get_line
    end
    return nil if lines.empty?
    lines.each{|l| l[0 ... indent] = ''}
    return OpenStruct.new(lines: lines, indent: indent)
  end


<< Parse deep bullet >>:
  margin = $~['margin']
  lines = [$~['separator'] + $']
  vp.get_line
  while !vp.eof? and
      vp.peek_line.start_with? margin and
      vp.peek_line !~ /^\s*-\s/ do
    lines.push vp.get_line[margin.length .. -1]
  end
  element = OpenStruct.new(
    type: OL_ITEM,
    lines: lines,
    content: parse_markup(lines.map(&:strip).join ' '),
    indent: margin.length,
    loc: element_location)


A standard chunk header is by its own a divert.  However, if
it's followed by an indented block, it's a chunk.

<< Vertical elements' parsing rules >>:

  when /^<<\s*
      (?: (?<root-type> \.file|\.script)\s+ )?
      (?<raw-name> [^\s].*?)
      \s*>>:$/x then
    name = canonicalise $~['raw-name']
    vp.get_line
    element = OpenStruct.new(
      type: OL_DIVERT,
      root_type: $~['root-type'],
      name: name,
      header_loc: element_location)

    body_location = vp.location_ahead
    body = vp.get_indented_lines_with_skip
    if body then
      element.type = OL_CHUNK
      element.lines = body.lines
      element.indent = body.indent
      element.body_loc = body_location
      element.initial = element.final = true
    end


Next, let's consider top-level bullets.

  when /^-\s/ then
    # We'll discard the leading dash but save the following
    # whitespace.
    lines = [vp.get_line[1 .. -1]]
    while !vp.eof? and
        vp.peek_line != '' and
        vp.peek_line !~ /^\s*-\s/ do
      lines.push vp.get_line
    end
    element = OpenStruct.new(
      type: OL_ITEM,
      lines: lines,
      content: parse_markup(lines.map(&:strip).join ' '),
      indent: 0,
      loc: element_location)


. [[OL_INDEX_ANCHOR]]

A line starting with a period and whitespace is an index
reference anchor.  This is a line-level, not paragraph-level,
notation so that multiple anchor lines can immediately follow
each other without the need for intervening whitespace.
Luckily, index keywords (or -phrases) are normally reasonably
short.

  when /^\.\s+/ then
    name = $'
    element = OpenStruct.new(
        type: OL_INDEX_ANCHOR,
        name: name)
    vp.get_line


Finally, a line starting with a non-whitespace character starts
an ordinary paragraph, a title, or a rubric.

  when /^[^\s]/ then
    lines = []
    while vp.peek_line =~ /^[^\s]/ and
        vp.peek_line !~ /^-\s/ do
      lines.push vp.get_line
    end
    mode_flags_to_suppress = 0
    case lines[0]
    << Rules for interpreting a paragraph-like element >>
    end
    element.lines = lines
    element.content =
        parse_markup(lines.map(&:strip).join(' '),
        mode_flags_to_suppress)


<< Rules for interpreting a paragraph-like element >>:

  when /^(==+)(\s+)/ then
    lines[0] = $2 + $'
    element = OpenStruct.new(
      type: OL_TITLE,
      level: $1.length - 1,
      loc: element_location)
    mode_flags_to_suppress |= Fabricator::MF::LINK


  when /^\*\s+/ then
    lines[0] = $'
    element = OpenStruct.new(
        type: OL_RUBRIC,
        loc: element_location)


  else
    element = OpenStruct.new(
        type: OL_PARAGRAPH,
        loc: element_location)


Now, let's go back to the main parsing loop.

Seeing two (or more) consecutive blank lines in front our
element triggers an explicit section break.

<< Handle explicit section break >>:
  if parser_state.vertical_separation >= 2 then
    integrator.force_section_break
  end


The integrator checks sections for emptiness (this would mean
that an explicitly delimited section contains only index
anchors), adds the [[[final]] tag to a diverted chunk chain's
last chunk, and checks whether a diversion actually applies to
any chunks when the chain ends.  Inside a fabric, this happens
by the appearance of certain types of elements -- chunks,
diversions, titles -- but when the fabric is over, we'll have to
make it explicit.

<< Handle the end of fabric >>:
  integrator.force_section_break
  integrator.clear_diversion


Once we have all the chunks, we can check that the root types of
all root chunks match each other.  It's not (usually) a serious
error, but the user might want to know.

  integrator.check_root_type_consistency


For this check, we iterate over chunk headers, so as not to
generate excessive warnings when the fault lies in a diversion.

. [[check_root_type_consistency]]
. "inconsistent root type" (warning)

<< in [[Integrator]] >>:
  def check_root_type_consistency
    @output.roots.each do |name|
      cbn_entry = @output.chunks_by_name[name]
      effective_root_type = cbn_entry.root_type
      cbn_entry.headers.each do |element|
        unless element.root_type == effective_root_type then
          warn element.header_loc,
              "inconsistent root type, assuming %s" %
                  effective_root_type
        end
      end
    end
    return
  end


* Vertical peekaboo.

The [[Vertical_Peeker]] class implements a line-level lookahead
on an [[IO]] instance.  We won't limit the lookahead, although
we'll only need two lines (when checking whether a blank line in
an indented block is followed by another indented line).

. [[Vertical_Peeker]]

<< in [[Fabricator]] >>:
  class Vertical_Peeker
    << in [[Vertical_Peeker]] >>
  end


<< in [[Vertical_Peeker]] >>:

  def initialize port
    super()
    @port = port
    if @port.respond_to? :path then
      @filename = @port.path
    elsif @port == $stdin then
      @filename = '(stdin)'
    else
      @filename = '(unknown)'
    end
    @buffer = []
    @line_number = 1 # number of the first line in the buffer
    @eof_seen = false
    return
  end


. [[peek_line]]

  def peek_line ahead = 0
    raise 'invalid argument' unless ahead >= 0
    until @buffer.length > ahead or @eof_seen do
      line = @port.gets
      if line then
        line.rstrip!
        @buffer.push line
      else
        @eof_seen = true
      end
    end
    return @buffer[ahead] # nil if past eof
  end


. [[get_line]] (method of [[Vertical_Peeker]])

  def get_line
    # ensure that if a line is available, it's in [[@buffer]]
    peek_line

    @line_number += 1 unless @buffer.empty?
    return @buffer.shift
  end


. [[eof?]] (method of [[Vertical_Peeker]])

  def eof?
    return peek_line.nil?
  end


. [[lineno_ahead]] (method of [[Vertical_Peeker]])

  def lineno_ahead
    return @line_number + (@line_consumed ? 1 : 0)
  end


. [[location_ahead]] (method of [[Vertical_Peeker]])

  def location_ahead
    return OpenStruct.new(
      filename: @filename, line: lineno_ahead)
  end


* Integration.

An [[Integrator]] builds an internal representation of a fabric
from the vertical elements extracted by a parser.

. [[Integrator]]

<< in [[Fabricator]] >>:
  class Integrator
    << in [[Integrator]] >>
  end


The root of the result, which will be a graph built out of
[[OpenStruct]]s, can be accessed by the method
[[Integrator#output]].

. [[output]] (accessor method of [[Integrator]])

<< in [[Integrator]] >>:
  attr_reader :output


Its top-level structure is evident from the initialisation
construct.

. [[@output]] (slot of [[Integrator]])

<< Initialise [[Integrator@output]] >>:
  @output = OpenStruct.new(
    << Fields of [[Integrator@output]] >>
  )


<< Fields of [[Integrator@output]] >>:

The /content/ of the fabric will be stored in the integrator
output under the key of [[presentation]].  In its immediate
form, it's a Ruby [[Array]] containing the [[OL_TITLE]] and
[[OL_SECTION]] nodes, in order; both of these kinds can contain
further, lower-level, structure.

  presentation: [], # list of titles and sections


In order to simplify generating the table of content of the
fabric, we'll furthermore gather the [[OL_TITLE]] and
[[OL_RUBRIC]] nodes into the integrator's output under the key
of [[toc]].  It's a flat list; however, [[OL_TITLE]] nodes will
define a hierarchical structure by their [[level]] fields.

  toc: [], # list of titles and rubrics.


In order to simplify /tangling/ of the files defined in the
fabric, we'll collect all their chunks into the integrator's
output structure under the key of [[chunks_by_name]].  (See also
[[canonicalise]].)

  chunks_by_name: {},
      # canonical_name => OpenStruct
      #   root_type: String,
      #   chunks: list of OL_CHUNK/OL_DIVERTED_CHUNK nodes,
      #   headers: list of OL_CHUNK/OL_DIVERT records,


Also, we'll collect the (canonicalised) names of the root
chunks.

  roots: [], # list of canonical names


Mau is a wiki engine, so in accordance with long-standing
custom, Maui strives to recover -- of course, not always very
well -- from almost all kinds of errors that it may detect
during processing a fabric object.  In order to help a human
diagnose and resolve such errors, it generates a /warning/ each
time it detects one, and we'll collect them into the
integrator's output structure.

  warnings: [],


. [[:manual]] (index reference type)
. [[:definition]] (index reference type)
. [[:transclusion]] (index reference type)

Last but not least, we'll collect /index reference entries/ of
three types ([[:manual]], [[:definition]], and
[[:transclusion]]), and arrange them for easy retrieval.

  index: {},
      # keyword => OpenStruct
      #   sort_key: string,
      #   canonical_representation: markup list,
      #   refs: [[number, reftype], ...],


The integrator has a number of other internal variables which
are only used while the fabric is being integrated.  In essence,
they hold a high-level state of the parser.  Let's initialise
them next:

<< in [[Integrator]] >>:

  def initialize first_section: 1
    super()
    << Initialise [[Integrator@output]] >>
    @cursec = nil # The current section if started
    @first_section_number = first_section
    @section_count = 0 # The number of last section
    @title_counters = [0]
    @curdivert = nil # The current diversion if active
    @last_divertee = nil
        # last chunk diverted by [[@curdivert]]
    @list_stack = nil
    @in_code = false
    @last_title_level = 0
    @warning_counter = 0
    return
  end


The integrator's main entry point.

. [[integrate]]

  def integrate element
    if element.type == OL_TITLE then
      << Integrate the title >>
    else
      << Integrate the part of section >>
    end
    return
  end


Title nodes are subject to level depth restriction, are
automatically numbered using three-level identifiers, and are in
addition to [[presentation]] collected into [[toc]].

. "title level too deep" (warning)

<< Integrate the title >>:
  # Check the title's level restriction
  if element.level > @last_title_level + 1 then
    warn element.loc, "title level too deep"
    element.level = @last_title_level + 1
  end
  @last_title_level = element.level

  # Number the title
  while @title_counters.length > element.level do
    @title_counters.pop
  end
  if @title_counters.length < element.level then
    @title_counters.push 0
  end
  @title_counters[-1] += 1
  element.number = @title_counters.join '.'

  # Append the node to [[presentation]] and [[toc]]
  force_section_break
  @output.presentation.push element
  @output.toc.push element

  # Enforce (sub(sub))chapter-locality of diversions
  clear_diversion


<< Integrate the part of section >>:
  << [[OL_BLOCK]] and diverting?  Upgrade to [[OL_DIVERTED_CHUNK]] >>
  << New chunk header?  Clear diversion >>
  << ? Break section and warn >>
  << ? Begin new section >>
  << [[OL_RUBRIC]]?  Link to [[toc]] >>
  << [[OL_DIVERT]]?  Apply it >>

  if element.type == OL_ITEM then
    << Integrate the list item >>
  elsif element.type == OL_INDEX_ANCHOR then
    << Add [[manual]] index entry >>
  else
    @list_stack = nil
    @cursec.elements.push element
    << Chunk or divert?  Parse and cross-reference >>

    # If a chunk body is followed by a narrative-type element,
    # we'll want to generate an automatic section break.  To
    # that end, we'll set the [[@in_code]] flag when we
    # encounter a node with a chunk body.
    if element.type & OLF_HAS_CODE != 0 then
      @in_code = true
    end
  end


An indented block can be either a piece of sample code, which is
just shown in the woven output, or a headerless code chunk,
which needs to be tangled, also.  Whether it's one or the other
depends on whether a diversion is in effect; a piece of context
that the parser does not track.  Accordingly, we'll upgrade
[[OL_BLOCK]] nodes to [[OL_DIVERTED_CHUNK]] nodes in the
integrator when a diversion is in effect.

This is also a convenient place to keep track of the chains of
diverted chunks.  To that end, we'll set the [[initial]] flag if
the current divert was not used before, and we'll also point
[[@last_divertee]] to the diverted block so that we can set the
[[final]] flag on it later.

<< [[OL_BLOCK]] and diverting?  Upgrade to [[OL_DIVERTED_CHUNK]] >>:
  if element.type == OL_BLOCK and @curdivert then
    element.type = OL_DIVERTED_CHUNK
    element.name = @curdivert.name
    element.divert = @curdivert

    element.initial = true if @last_divertee.nil?
    @last_divertee = element
  end


<< New chunk header?  Clear diversion >>:
  if element.type & OLF_HAS_HEADER != 0 then
    clear_diversion
  end


As Knuth's original WEB did, we'll generally follow the
rubric-narrative-code structure in our sections, with the main
difference being that multiple chunks can appear in a single
section.  A transition from code to narrative thus causes a
section break.

Also, a [[OL_RUBRIC]] node causes a section break.

In both cases, we'll warn the user if there wasn't an explicit
section break in the form of two adjacent blank lines.

. "silent section break" (warning)

<< ? Break section and warn >>:
  if (@cursec and element.type == OL_RUBRIC) or
      (@in_code and element.type & OLF_NARRATIVE != 0) then
    (@cursec.warnings ||= []).push \
        warn(element.loc,
            "silent section break",
            inline: true)
    force_section_break
  end


<< ? Begin new section >>:
  if @cursec.nil? then
    @cursec = OpenStruct.new(
      type: OL_SECTION,
      section_number: @first_section_number +
          @section_count,
      elements: [],
      loc: element.loc)
      @section_count += 1
    @output.presentation.push @cursec
  end


<< [[OL_RUBRIC]]?  Link to [[toc]] >>:
  if element.type == OL_RUBRIC then
    element.section_number = @cursec.section_number
    @output.toc.push element
  end


<< [[OL_DIVERT]]?  Apply it >>:
  if element.type == OL_DIVERT then
    @curdivert = element
    raise 'assertion failed' unless @last_divertee.nil?
  end


<< Integrate the list item >>:
  # Is this a top-level or descendant item?
  unless @list_stack then
    raise 'assertion failed' unless element.indent == 0

    # Create a new [[OL_LIST]] node.
    new_list = OpenStruct.new(
      type: OL_LIST,
      items: [],
      indent: element.indent)
    @cursec.elements.push new_list
    @list_stack = [new_list]
  else
    << Discard pending lists deeper than [[element.indent]] >>
    << ? Start a new sublist >>
  end

  # The list structure has been prepared.  Append the
  # new element to the innermost list in progress.
  @list_stack.last.items.push element


. "unexpected dedent" (warning)

<< Discard pending lists deeper than [[element.indent]] >>:
  while @list_stack.last.indent > element.indent do
    if @list_stack[-2].indent < element.indent then
      # Unexpected de-dent, like this:
      #    - master list
      #         - child 1
      #       - child 2
      @list_stack.last.indent = element.indent
      (element.warnings ||= []).push \
          warn(element.loc,
              "unexpected dedent", inline: true)
      break
    end
    @list_stack.pop
  end


<< ? Start a new sublist >>:
  if @list_stack.last.indent < element.indent then
    if @list_stack.last.sublist then
      raise 'assertion failed'
    end
    new_list = OpenStruct.new(
      type: OL_LIST,
      items: [],
      indent: element.indent)
    @list_stack.last.items.last.sublist = new_list
    @list_stack.push new_list
  end


Integrating an index anchor only involves adding an entry to the
index; the [[OL_INDEX_ANCHOR]] node won't be appended into the
body of the containing [[OL_SECTION]] node.

<< Add [[manual]] index entry >>:
  freeform_index_record(element.name).refs.push [
      @cursec.section_number, :manual]


Chunks come out of the parser as series of lines.  For
cross-referencing and tangling, we'll need a slightly more
complex presentation: a sequence of ([[verbatim]]), reference
([[use]] and [[newline]] nodes.  This parsing is done by the
integrator.  (It can't be done in the parser because it can't
tell apart sample code from true chunks if the latter have no
headers.)

Chunk parsing is done by scanning the [[lines]] field of the
chunk node and constructing a new field, [[content]], along it.
[[content]] is not line-oriented; rather, it has [[newline]]
nodes to separate lines.  This makes the tangling loop a bit
easier.

<< Parse the chunk's content >>:
  element.content = []
  element.lines.each_with_index do
      |line, lineno_in_chunk|
    unless lineno_in_chunk.zero? then
      element.content.push \
          OpenStruct.new(type: :newline)
    end
    << Parse a line of chunk content >>
  end


When parsing chunk lines, we'll want to properly pinpoint the
locations of [[use]] nodes so that we can issue correct
warnings.  We'll do this by starting from the number of the
chunk's leftmost column and updating it as we traverse through
the line, which we'll split using [[String#split]] with a
capturing regex.

<< Parse a line of chunk content >>:
  column = 1 + element.indent
  line.split(/(<<\s*
      (?:
       \[\[.*?\]*\]\]
       | .
      )+?
      \s*>>)/x, -1).each_with_index do
        |raw_piece, piece_index|
    << Parse a piece of a line of chunk content >>
    column += raw_piece.length
  end

<< Parse a piece of a line of chunk content >>:
  node = nil
  if piece_index.odd? then
    << Attempt to parse [[raw_piece]] as a [[use]] node >>
    # If failed, [[node]] is still [[nil]].
  end
  if node.nil? and !raw_piece.empty? then
    node = OpenStruct.new(
      type: :verbatim,
      data: raw_piece)
  end
  element.content.push node if node

<< Attempt to parse [[raw_piece]] as a [[use]] node >>:
  name = raw_piece[2 ... -2].strip
      # discard the surrounding double brokets
      # together with adjacent whitespace
  node = OpenStruct.new(type: :use,
      name: nil,
          # for ordering; will be replaced below
      raw: raw_piece,
      loc: OpenStruct.new(
          filename: element.body_loc.filename,
          line: element.body_loc.line +
              lineno_in_chunk,
          column: column)
  )
  << Extract affixes from [[name]] into [[node]] >>
  if !name.empty? then
    node.name =
        Fabricator.canonicalise(name)
  else
    # not a proper reference, after all
    node = nil
  end

<< Extract affixes from [[name]] into [[node]] >>:
  if name =~ /(?:^|\s+)(\|[\w>-]+)$/ and
      Fabricator::POSTPROCESSES.has_key? $1 then
    node.postprocess = $1; name = $`
  end
  if name =~ /(?:^|\s+)(\.dense)$/ then
    node.vertical_separation = $1; name = $`
  end
  if name =~ /^(\.clearindent)(?:\s+|$)/ then
    node.clearindent = true; name = $'
  end


Chunks and diverts we'll be linking under [[chunk_by_name]].
We'll keep separate track of chunk bodies ([[OL_CHUNK]] or
[[OL_DIVERTED_CHUNK]]), linked under
[[chunks_by_name[...].chunks]], and chunk headers ([[OL_CHUNK]]
or [[OL_DIVERT]]), linked under [[chunks_by_name[...].headers]].

<< Chunk or divert?  Parse and cross-reference >>:
  if element.type & OLF_HAS_CODE != 0 then
    element.section_number = @cursec.section_number
    << Parse the chunk's content >>
  end

  if element.type & OLF_FUNCTIONAL != 0 then
    cbn_record =
        @output.chunks_by_name[element.name] ||=
            OpenStruct.new(chunks: [], headers: [])

    if element.type & OLF_HAS_HEADER != 0 then
      cbn_record.headers.push element
      << Root?  Check the filename for sanity >>
      << Update [[cbn_record.root_type]] from [[element]] >>
    end

    case element.type
      << [[case]] clauses to index a [[definition]] >>
      else
        raise 'assertion failed'
    end

    # Do we have a chunk body?
    if element.type & OLF_HAS_CODE != 0 then
      cbn_record.chunks.push element
      << Create [[transclusion]] index entries >>
    end
  end


. "unuseable filename" (warning)

<< Root?  Check the filename for sanity >>:
  if element.root_type then
    if !Fabricator.filename_sane? element.name then
      (element.warnings ||= []).push \
          warn(element.header_loc,
              "unuseable filename",
              inline: true)
      element.root_type = nil
    end
  end


. [[filename_sane?]]

<< Other methods >>:
  def filename_sane? name
    parts = name.split '/', -1
    return false if parts.empty?
    parts.each do |p|
      return false if ['', '.', '..'].include? p
      return false unless p =~ /\A[\w.-]+\Z/
    end
    return true
  end


The [[:chunks_by_name]] record will hold the highest root type
for chunks of this name, with the order defined as [[nil]] <
[['.file']] < [['.script']].

<< Update [[cbn_record.root_type]] from [[element]] >>:
  if element.root_type and
      cbn_record.root_type.nil? then
    cbn_record.root_type = element.root_type
    @output.roots.push element.name
  end
  if element.root_type == '.script' then
    cbn_record.root_type = element.root_type
  end


<< [[case]] clauses to index a [[definition]] >>:

For an ordinary chunk, we'll just create a new index reference
entry.

. [[:definition]] (index reference type)

  when OL_CHUNK then
    chunk_index_record(element.name).refs.push [
        @cursec.section_number, :definition]


For a divert, we'll create an index reference entry with a range
in the place of the section number.  Initially, the range will
have the section number the divert appears in as both of its
endpoints.

. [[:definition]] (index reference type)

  when OL_DIVERT then
    index_ref = [@cursec.section_number ..
        @cursec.section_number, :definition]
    chunk_index_record(element.name).refs.push(
        index_ref)
    # We'll add a pointer to this reference entry
    # into [[@curdivert]] so we can replace the
    # range later to cover all the sections in which
    # headerless chunks collected by this divert are
    # present.
    @curdivert.index_ref = index_ref


For a diverted entry, we won't create a new index reference
entry but replace the previously existing one to also include
the new section.

  when OL_DIVERTED_CHUNK then
    prev_range = @curdivert.index_ref[0]
    @curdivert.index_ref[0] = prev_range.begin ..
        @cursec.section_number


. [[:transclusion]] (index reference type)

<< Create [[transclusion]] index entries >>:
  element.content.each do |node|
    next unless node.type == :use
    chunk_index_record(node.name).refs.push [
        @cursec.section_number, :transclusion]
  end


<< in [[Integrator]] >>:

. [[chunk_index_record]]

  def chunk_index_record name
    identifier = "<< " +
        Fabricator.canonicalise(name) +
        " >>"
    markup = [OpenStruct.new(
        type: MU_MENTION_CHUNK,
        name: name)]
    return _index_record identifier, markup
  end


. [[freeform_index_record]]

  def freeform_index_record name
    identifier = Fabricator.canonicalise(name)
    markup = Fabricator.parse_markup name,
            Fabricator::MF::LINK
    return _index_record identifier, markup
  end


. [[_index_record]] (method of [[Integrator]])

  def _index_record identifier, markup
    return @output.index[identifier] ||=
        OpenStruct.new(
            sort_key: identifier.downcase.sub(
                /^([^[:alnum:]]+)(.*)$/) {
                $2 + ", " + $1},
            canonical_representation: markup,
            refs: [],
        )
  end


This concludes the main integration decision tree.


* Integrator's utilities.

<< in [[Integrator]] >>:

. [[force_section_break]]
. "section with index anchor(s) but no content"

  def force_section_break
    if @cursec and @cursec.elements.empty? then
      # Section nodes are only created when there's at least
      # one element to be integrated.  This element may be an
      # index anchor, which is not actually added into the
      # section's [[elements]] list.  Since this is the only
      # such case, the meaning of [[elements]] being empty by
      # the end of the section is unambiguous.
      (@cursec.warnings ||= []).push \
          warn(@cursec.loc,
              "section with index anchor(s) but no content",
              inline: true)
    end
    @cursec = nil
    @list_stack = nil
    @in_code = false
    return
  end


In addition to clearing [[@curdivert]], [[clear_diversion]] also
sets the [[final]] flag of the last divertee in a chain.  In
order for this to work properly, the main parser calls this, via
<< Handle the end of fabric >>, once the input fabric ends.

. [[clear_diversion]]
. "unused diversion" (warning)
. "single-use diversion" (warning)

  def clear_diversion
    if @curdivert then
      if !@last_divertee then
        (@curdivert.warnings ||= []).push \
            warn(@curdivert.header_loc,
                "unused diversion",
                inline: true)
      elsif @last_divertee.initial then
        (@curdivert.warnings ||= []).push \
            warn(@curdivert.header_loc,
                "single-use diversion",
                inline: true)
      end
      @curdivert = nil
      @last_divertee.final = true if @last_divertee
      @last_divertee = nil
    end
    return
  end


. space-dash-space ambiguity
In order to resolve the space-dash-space ambiguity, the
front-end parser whether a list is currently active.  It can't
determine that itself because implicit section breaks, which
clear active list status, are generated by the integrator; thus,
it needs to ask the integrator.

. [[in_list?]] (method of [[Integrator]])

  def in_list?
    return !@list_stack.nil?
  end


* Chunk length limit check.

. [[check_chunk_sizes]]
. "long chunk" (warning)
. "very long chunk" (warning)

<< in [[Integrator]] >>:
  def check_chunk_sizes limit
    return unless limit
    @output.presentation.each do |node|
      next unless node.type == OL_SECTION
      node.elements.each do |element|
        next unless element.type == OL_CHUNK
        if element.lines.length > limit then
          if element.lines.length > limit * 2 then
            assessment, factor = "very long chunk", 2
          else
            assessment, factor = "long chunk", 1
          end
          limit_loc = element.body_loc.dup
          limit_loc.column = nil
          limit_loc.line += limit * factor
          (element.warnings ||= []).push \
              warn(limit_loc, "%s (%i lines)" %
                      [assessment, element.lines.length],
                  inline: true)
        end
      end
    end
    return
  end


* The warning subsystem.

Warnings are recorded in the [[warnings]] list of a fabric and
may also be recorded in individual elements.
[[Integrator#warn]] generates a record for such storage.  Note
that it does not actually display the warning, for the fabric
loader doesn't really know anything about the I/O system
available for this.

. [[warn]] (method of [[Integrator]])

<< in [[Integrator]] >>:
  def warn location, message, inline: false
    record = OpenStruct.new(
      loc: location,
      message: message,
      number: @warning_counter += 1,
      inline: inline)
    @output.warnings.push record
    return record # so it can also be attached elsewhere
  end


In the command line interface, we'll output the warnings once a
fabric has been fully loaded.

. [[show_warnings]]

<< Other methods >>:
  def show_warnings fabric
    fabric.warnings.each do |warning|
      $stderr.puts "%s: %s" %
          [format_location(warning.loc), warning.message]
    end
    return
  end


* Location pinpointing.

Locations are encoded using [[OpenStruct]] instances with the
fields [[filename]] and [[line]] and optionally [[column]].

<< Other methods >>:

. [[format_location]]

  def format_location h
    if h.column then
      return "%s:%i.%i" % [h.filename, h.line, h.column]
    else
      return "%s:%i" % [h.filename, h.line]
    end
  end


In order to encode a region's location, we'll save its two
endpoints, both inclusive, in an [[OpenStruct]] instance as
[[from]] and [[to]], as standard locations.  The [[dash]] is a
parameter so as to permit n-dash to be used in HTML output.

. [[format_location_range]]

  def format_location_range h, dash: "-"
    if h.from.filename != h.to.filename then
      return format_location(h.from) + dash +
          format_location(h.to)
    else
      if h.from.line != h.to.line then
        result = h.from.filename + ":"
        result << h.from.line.to_s
        result << "." << h.from.column.to_s if h.from.column
        result << dash
        result << h.to.line.to_s
        result << "." << h.to.column.to_s if h.to.column
      else
        result = h.from.filename + ":"
        result << h.from.line.to_s
        if h.from.column or h.to.column then
          result << "." <<
            h.from.column.to_s << dash << h.to.column.to_s
        end
      end
      return result
    end
  end


* Node types.

A parsed fabric's internal representation is, for the most part,
a tree consisting of three layers of different nodes: /outline/
nodes such as titles and paragraphs, /markup/ nodes, and
/sub-chunk/ nodes.  The following constants are used to encode
the types of nodes generated as a fabric is being parsed. 

Many of these values are chosen arbitrarily.  Some have special
bit patterns to them.

<< in [[Fabricator]] >>:


Let's first consider the outline nodes' types.  We'll reserve
two bits for the [[OLF_HAS_HEADER]] and [[OLF_HAS_CODE]] flags.

. [[OLF_HAS_HEADER]]
. [[OLF_HAS_CODE]]
. [[OLF_FUNCTIONAL]]

  OLF_HAS_HEADER     = 0x01
  OLF_HAS_CODE       = 0x02
  OLF_FUNCTIONAL     = OLF_HAS_HEADER | OLF_HAS_CODE


We'll also reserve one bit for the [[OLF_NARRATIVE]] flag.  When
the parser (front-end) sees a node with this flag set, it'll
force a section break and warn.  There's no strict need to
attach this flag to [[OL_LIST]], because it's checked by the
parser front-end which sees only items, not lists (as list
containers are built from separate items by the parser's
back-end, [[Integrator]]), nor to [[OL_RUBRIC]], because a
rubric element starts a new section explicitly, but we'll do it
anyway in order to slightly simplify the flag's conceptual
semantics: it marks major narrative nodes.

. [[OLF_NARRATIVE]]

  OLF_NARRATIVE      = 0x08


Now, we can enumerate the node types.

. [[OL_RUBRIC]]
. [[OL_ITEM]]
. [[OL_LIST]]
. [[OL_PARAGRAPH]]
. [[OL_BLOCK]]
. [[OL_DIVERT]]
. [[OL_DIVERTED_CHUNK]]
. [[OL_CHUNK]]
. [[OL_INDEX_ANCHOR]]

  OL_TITLE           = 0x10
  OL_SECTION         = 0x20
  OL_RUBRIC          = 0x30 | OLF_NARRATIVE
  OL_ITEM            = 0x40 | OLF_NARRATIVE
  OL_LIST            = 0x50 | OLF_NARRATIVE
  OL_PARAGRAPH       = 0x60 | OLF_NARRATIVE
  OL_BLOCK           = 0x70 | OLF_NARRATIVE
  OL_DIVERT          = 0x80 | OLF_HAS_HEADER
  OL_DIVERTED_CHUNK  = 0x80 | OLF_HAS_CODE
  OL_CHUNK           = 0x80 | OLF_HAS_HEADER | OLF_HAS_CODE
  OL_INDEX_ANCHOR    = 0x90


Next, we'll consider the markup nodes.  First, in
[[Markup_Constructor#words]], which is frequently called as it
has to process all the narrative content of a fabric, we parse
free-flow text by regex-splitting a paragraph at space, and
iterating over the result using [[each_with_index]].  The markup
nodes thus generated have a natural checkerboard pattern: the
zeroth one necessarily has type [[MU_PLAIN]], the next one
[[MU_SPACE]], then again [[MU_PLAIN]], and so on.  By choosing
[[MU_PLAIN]] to be zero and [[MU_SPACE]] to be one, we can
translate the index of a piece into its markup node type value
with only one arithmetic operation -- [[i & 1]], and won't have
to use branching of any sort.

. [[MU_PLAIN]]
. [[MU_SPACE]]
. [[MU_NBSP]]
. [[MU_BOLD]]
. [[MU_ITALIC]]
. [[MU_UNDERSCORE]]
. [[MU_MONOSPACE]]
. [[MU_LINK]]
. [[MU_MENTION_CHUNK]]

  MU_PLAIN           = 0x00
  MU_SPACE           = 0x01
  MU_NBSP            = 0x02
  MU_BOLD            = 0x03
  MU_ITALIC          = 0x04
  MU_UNDERSCORE      = 0x05
  MU_MONOSPACE       = 0x06
  MU_LINK            = 0x07
  MU_MENTION_CHUNK   = 0x08


== Horizontal parsing

* Chunk name canonicalisation.

This amounts to compressing all whitespace that is not marked as
monospaced by double brackets.

. [[canonicalise]]

<< Other methods >>:
  def canonicalise raw_name
    name = ''
    raw_name.strip.split(/(\[\[.*?\]*\]\])/, -1).
        each_with_index do |part, i|
      part.gsub! /\s+/, ' ' if i.even?
      name << part
    end
    return name
  end


* Markup parsing.

The markup parser materialises as a function that takes a string
as its input and returns a list of syntactic nodes.  The parser
itself is a fairly simple linear scanner, the main trick being
[[Markup_Parser_Stack]] that holds the currently open markup
constructs.

. [[parse_markup]]

<< Other methods >>:
  def parse_markup s, suppress_modes = 0
    ps = Fabricator::Pointered_String.new s
    stack = Fabricator::Markup_Parser_Stack.new suppress_modes
    while ps.pointer < s.length do
      << Parse a bit of markup >>
    end
    while stack.length > 1 do
      stack.unspawn
    end
    return stack.last.content
  end


So, let's consider [[Markup_Parser_Stack]] next.  Since it's a
stack, we'll derive it from [[Array]]:

. [[Markup_Parser_Stack]]

<< in [[Fabricator]] >>:
  class Markup_Parser_Stack < Array
    << in [[Markup_Parser_Stack]] >>
  end


At initialisation, the stack will have one frame.  We'll
[[content]] holds collected markup nodes in a
[[Markup_Constructor]] instance (which inherits from [[Array]]);
[[mode]] is a bitfield bit, as used in mode, but it is not a
bitfield.  for currently permitted markup notations, and
[[term_type]] is implement stack frames as [[OpenStruct]]
instances.  The slot the frame marker for unwinding.
[[term_type]] normally holds a

<< in [[Markup_Parser_Stack]] >>:
  def initialize suppress_modes = 0
    super()
    push OpenStruct.new(
        content: Fabricator.markup,
        mode: Fabricator::MF::DEFAULTS & ~suppress_modes,
        term_type: 0,
      )
    return
  end


Next, let's list all the bits a [[Markup_Parser_Stack]] frame's
[[mode]] can hold:

<< in [[Fabricator]] >>:
  module MF
    BOLD            = 0x01
    END_BOLD        = 0x02
    ITALIC          = 0x04
    END_ITALIC      = 0x08
    UNDERSCORE      = 0x10
    END_UNDERSCORE  = 0x20
    LINK            = 0x40
    END_LINK        = 0x80

    DEFAULTS = BOLD | ITALIC | UNDERSCORE | LINK
  end


Whenever the markup parser encounters what looks like a markup
start notation, it /spawns/ a new frame onto the stack.  The new
frame will contain the notation as [[face]] so that we can
[[unspawn]] it, should the start later turn out to be a false
start.  It overrides the [[mode]] of the top stack frame by
enabling the corresponding markup's end notation and disabling
another start notation of the same kind.  Finally, it tags the
new frame with a [[term_type]], which is used in order to find
this stack frame when we actually get to the end notation.

[[OpenStruct]]'s flexibility lets us add extra fields when
needed.  This is useful for dealing with links, as we'll see
later.

<< in [[Markup_Parser_Stack]] >>:

. [[spawn]] (method of [[Markup_Parser_Stack]])

  def spawn face, start_flag, end_flag
    self.push OpenStruct.new(
      face: face,
      content: Fabricator.markup,
      mode: self.last.mode & ~start_flag | end_flag,
      term_type: end_flag,
    )
    return
  end


The frame can be merged back into its parent frame by
/unspawning/ it.  This happens when we need to reinterpret what
once looked like a start notation as a plain piece of string.

. [[unspawn]]

  def unspawn
    raise 'assertion failed' unless length >= 2
    top = self.pop
    self.last.content.
        plain(top.face).
        concat(top.content)
    return
  end


Finally, when we encounter a valid markup end notation, we'll
wrap up the current stack frame, /ennoding/ its [[content]] into
the matching ancestral stack frame's.  Because the markup region
may contain a few intervening faux start notations, we may have
to first unspawn a few times; the [[frame_type]] parameter will
tell [[ennode]] how to recognise the last stack frame to eat up.

. [[ennode]]

  def ennode node_type, frame_type, **attr
    while self.last.term_type != frame_type do
      self.unspawn
    end
    top = self.pop
    self.last.content.node node_type,
        content: top.content,
        **attr
    return
  end


Let's now consider the main markup parsing loop.  We'll set it
up as a series of [[if ... elsif ... elsif ... end]] clauses.

The easiest markup to parse is undoubtedly [[[[foo]]]] for
monospaced text, which doesn't even need a stack frame.  The
main trick here is that if the terminal [[]]]] contains more
than two adjacent closing brackets, we'll pick the two last
ones.  This trick, originally from Norman Ramsey's [[noweb]],
lets the user to use multiple terminal closing brackets in a
natural manner, as in [[[[a[b[i]]]]]].

When parsing the monospaced string, we'll split it into
[[MU_PLAIN]] and [[MU_SPACE]] nodes.  This is one of the rare
cases in Maui's notation when whitespace needs to be recorded,
for we'll want to retain sequences of multiple whitespaces in
monospaced text.

<< Parse a bit of markup >>:
  if ps.at? "[[" and
      end_offset = s.index("]]", ps.pointer + 2) then
    while ps[end_offset + 2] == ?] do
      end_offset += 1
    end
    stack.last.content.node MU_MONOSPACE,
        content: Fabricator.markup.
            words(ps[ps.pointer + 2 ... end_offset].strip)
    ps.pointer = end_offset + 2


Detecting the notation for *bold*, /italic/, or _underscore_ is
a bit more complicated, so we'll encapsulate it in a separate
function.  Since it operates on a [[Pointered_String]], we'll
insert it into it as an extra method.

The main rules are:
- the starting character is alone, not next to another copy of
  itself, and
- the starter is not immediately followed by a whitespace.

. [[biu_starter?]]

<< in [[Pointered_String]] >>:
  def biu_starter? c
    return char_ahead == c &&
        char_ahead(-1) != c &&
        ![?\s, c].include?(char_ahead(1))
  end


When these conditions trigger, we'll establish a new markup
parser stack frame:

<< Parse a bit of markup >>:
  elsif stack.last.mode & Fabricator::MF::BOLD != 0 and
      ps.biu_starter? ?* then
    stack.spawn '*',
        Fabricator::MF::BOLD,
        Fabricator::MF::END_BOLD
    ps.pointer += 1

  elsif stack.last.mode & Fabricator::MF::ITALIC != 0 and
      ps.biu_starter? ?/ then
    stack.spawn '/',
        Fabricator::MF::ITALIC,
        Fabricator::MF::END_ITALIC
    ps.pointer += 1

  elsif stack.last.mode & Fabricator::MF::UNDERSCORE \
          != 0 and
      ps.biu_starter? ?_ then
    stack.spawn '_',
        Fabricator::MF::UNDERSCORE,
        Fabricator::MF::END_UNDERSCORE
    ps.pointer += 1


The conditions for BIU-terminating markup are similar, except
in this case, we'll prohibit whitespace /preceding/ the
markup character.

. [[biu_terminator?]]

<< in [[Pointered_String]] >>:
  def biu_terminator? c
    return char_ahead == c &&
        char_ahead(1) != c &&
        ![?\s, c].include?(char_ahead(-1))
  end


The parser's rules are similarly straightforward, too.

<< Parse a bit of markup >>:

  elsif stack.last.mode & Fabricator::MF::END_BOLD != 0 and
      ps.biu_terminator? ?* then
    stack.ennode MU_BOLD, Fabricator::MF::END_BOLD
    ps.pointer += 1

  elsif stack.last.mode & Fabricator::MF::END_ITALIC \
          != 0 and
      ps.biu_terminator? ?/ then
    stack.ennode MU_ITALIC, Fabricator::MF::END_ITALIC
    ps.pointer += 1

  elsif stack.last.mode & Fabricator::MF::END_UNDERSCORE \
          != 0 and
      ps.biu_terminator? ?_ then
    stack.ennode MU_UNDERSCORE, Fabricator::MF::END_UNDERSCORE
    ps.pointer += 1


Let's now move on to parsing links.

Maui's basic link notation is [[<override|target>]], or when
override is not desired, just [[<target>]].  This presents a
slight conundrum, in that when we pass the initial [[<]], we
don't yet know whether we should parse the following as
marked-up text -- for the /override/ -- or as a plain string --
for /target/.  We'll resolve this by beginning parsing as plain
text, but storing the offset of the initial broket in the stack
frame as [[start_offset]] so we can return to the beginning,
should we encounter the terminal [[>]] without an intervening
[[|]].

  elsif stack.last.mode & Fabricator::MF::LINK != 0 and
      ps.biu_starter? ?< then
    stack.spawn '<',
        Fabricator::MF::LINK,
        Fabricator::MF::END_LINK
    stack.last.start_offset = ps.pointer
    ps.pointer += 1


When we see [[|]], we have completed parsing the link's
override.  We can now pick up the plain-text link target,
terminated by [[>]], and wrap up the link node.

  elsif stack.last.mode & Fabricator::MF::END_LINK != 0 and
      ps.at? '|' and
      end_offset = s.index(?>, ps.pointer + 1) then
    target = ps[ps.pointer + 1 ... end_offset]
    if link_like? target then
      stack.ennode MU_LINK,
          Fabricator::MF::END_LINK,
          target: target
      ps.pointer = end_offset + 1
    else
      # False alarm: this is not a link, after all.
      stack.cancel_link
      stack.last.content.plain '|'
      ps.pointer += 1
    end


When we see [[>]] with [[END_LINK]] enabled, we know that
this is an unoverridden link.  The text between the brokets is
now supposed to be plain text link, any markup-like looking
symbols such as underscores or slashes notwithstanding, so we'll
discard the work we did trying to parse this as markup, and
construct a simple link node.

  elsif stack.last.mode & Fabricator::MF::END_LINK != 0 and
      ps.at? '>' then
    j = stack.rindex do |x|
      x.term_type == Fabricator::MF::END_LINK
    end
    target = ps[stack[j].start_offset + 1 ... ps.pointer]
    if link_like? target then
      stack[j .. -1] = []
      stack.last.content.node MU_LINK,
          implicit_face: true,
          target: target,
          content: Fabricator.markup.plain(target)
    else
      # False alarm: this is not a link, after all.
      stack.cancel_link
      stack.last.content.plain '>'
    end
    ps.pointer += 1


The [[link_like?]] test lets us avoid misinterpreting some
(very) basic broketed constructs such as [[<*>]] --- which may
appear when Maui wikitext is generated by copy-pasting
ASCII-formatted text --- as links.

. [[link_like?]]

<< Other methods >>:
  def link_like? s
    return !!(s =~ /\A(?:#\s*)?[[:alnum:]]/)
  end


When an apparent link turns out to not be a link at all, we'll
/cancel/ it.  This involves clearing the [[END_LINK]] flag
(and the relevant [[term_type]]) in all affected stack frames
and restoring the [[LINK]] flag so that we can parse another,
more proper link.  (Note that we can always restore [[LINK]]:
[[cancel_link]] is only called if we were in [[END_LINK]]
mode, and this makes only sense if, at a previous point in
parsing, we had [[LINK]] set and encountered an opening broket.)
We can't perform unwinding at this point because we may have
passed over starts of some markup regions which have not ended
yet but will end later.

. [[cancel_link]] (method of [[Markup_Parser_Stack]])

<< in [[Markup_Parser_Stack]] >>:
  def cancel_link
    i = self.length
    begin
      i -= 1
      self[i].mode &= ~Fabricator::MF::END_LINK
      self[i].mode |= Fabricator::MF::LINK
    end until self[i].term_type == Fabricator::MF::END_LINK
    self[i].term_type = 0
    return
  end


Because whitespace has meaning for Maui markup --- it indicates
places suitable for linebreaks when word-wrapping ---, we'll
parse it as a kind of special node.

<< Parse a bit of markup >>:
  elsif ps.at? ' ' then
    ps.pointer += 1
    while ps.at? ' ' do
      ps.pointer += 1
    end
    stack.last.content.space


We'll consider the [[U+00A0 NO-BREAK SPACE]] a form of markup.
Each such character will be a node of the type [[MU_NBSP]], with
no attributes.

<< Parse a bit of markup >>:
  elsif ps.at? "\u00A0" then
    stack.last.content.node MU_NBSP
    ps.pointer += 1


Finally, if none of the rules matched, we'll pick the following
character up as a plain text node.  As an optimisation, we'll
merge it with any following characters that definitely are not
markup characters.  Since we don't want the generated node's
[[data]] field to retain the type of [[Pointered_String]], we'll
construct a new [[String]] instance with its content.

<< Parse a bit of markup >>:
  else
    j = ps.pointer + 1
    while j < s.length and !" */<>[_|".include? ps[j] do
      j += 1
    end
    stack.last.content.plain String.new(ps[ps.pointer ... j])
    ps.pointer = j
  end


* String traversal.

The final part of the markup parser's puzzle is
[[Pointered_String]], which provides convenient lookahead (and
lookbehind) while traversing the string.  We'll derive it from
[[String]] by augmenting it with the [[pointer]] field.

. [[Pointered_String]]

<< in [[Fabricator]] >>:
  class Pointered_String < String
    def initialize value
      super value
      @pointer = 0
      return
    end

    attr_accessor :pointer

    << in [[Pointered_String]] >>
  end


The most basic operation is extracting up to a given number of
characters of lookahead.

<< in [[Pointered_String]] >>:

. [[ahead]] (method of [[Pointered_String]])

  def ahead length
    return self[@pointer, length]
  end


An alternative way of lookahead extracts only a single
character, specified via a relative offset from [[@pointer]].
The [[delta]] parameter can be negative for lookbehind, and
attempts to look before the string begins produce [[nil]] rather
than wrapping over to the end of the string.

. [[char_ahead]] (method of [[Pointered_String]])

  def char_ahead delta = 0
    offset = @pointer + delta
    return offset >= 0 ? self[offset] : nil
  end


Parsing decisions often depend on whether the current lookahead
matches an etalon.  We'll call this operation [[at?]].

. [[at?]] (method of [[Pointered_String]])

  def at? etalon
    return ahead(etalon.length) == etalon
  end


There is no point in implementing basic methods for moving
[[@pointer]] around, as it has already been fully exposed.


* Construction outside parser.

In order to simplify constructing the markup structures, we'll
subclass [[Array]] into a variant with methods for the markup
node types.  Calling any such a method results in appending a
matching [[OpenStruct]] to the array.

. [[markup]] (procedure)

<< Other methods >>:
  def markup
    return Fabricator::Markup_Constructor.new
  end

. [[Markup_Constructor]]

<< in [[Fabricator]] >>:
  class Markup_Constructor < Array
    << in [[Markup_Constructor]] >>
  end


Let's first write an abstract appender and specialise it later.

<< in [[Markup_Constructor]] >>:

. [[node]] (method of [[Markup_Constructor]])

  def node type, **attr
    return push(OpenStruct.new(type: type, **attr))
    # [[Array#push]] will return self, allowing [[node]] calls
    # to be chained.
  end


. [[plain]] (method of [[Markup_Constructor]])

  def plain data
    return node(MU_PLAIN, data: data)
  end


. [[space]] (method of [[Markup_Constructor]])

  def space data = nil
    return node(MU_SPACE, data: data)
  end


Now, in order to have some convenience atop our convenience,
we'll define the [[words]] method that will parse a given string
into 'whitespace' and 'other'.  This distinction in the markup
is necessary to make sure the whitespace can be broken when
word-wrapping the result.

. [[words]] (method of [[Markup_Constructor]])

  def words s
    s.split(/(\s+)/, -1).each_with_index do |part, i|
      # Note that 0 is [[MU_PLAIN]] and 1 is [[MU_SPACE]].
      node(i & 1, data: part)
    end
    return self
  end


== Tangling

* The main tangling loop.

Our tangler does not treat the parsed fabric as a purely passive
object; rather, it adds cross-references, annotates chunks with
the output locations, and issues warnings over reference
problems.  Thus, it lives inside the [[Integrator]].  In order
to not mislead the programmer to think it's the top-level
tangling method, we'll give it a more specific name:
[[tangle_chunks]].

It takes four parameters: [[cbn_entry]] is the
[[chunks_by_name]] entry of the node to be tangled (we'll pass a
pre-resolved node so as to prevent resolution failure at this
point), [[sink]] is the [[Tangling_Sink]] instance to use,
[[trace]] is a [[Set]] used to detect circular references, and
[[vsep]] can override the number of linebreaks to be generated
between adjacent chunks.  By default, we'll leave one blank
line, hence two linebreaks.  The [[.dense]] option removes the
blank line, leaving only one separating linebreak.

During tangling, we'll collect each chunk's tangling locations.
(Note that it's possible that one chunk will be tangled into
multiple places).  We'll store this data into the chunk as the
[[tangle_locs]] list.  We'll also collect tangling locations of
chunk chains -- sequences of [[OL_DIVERTED_CHUNK]] elements
diverted by the same divert.  We'll store this data into the
[[OL_DIVERT]] node as the [[chain_tangle_locs]] list.

. [[tangle_chunks]]

<< in [[Integrator]] >>:
  def tangle_chunks cbn_entry, sink, trace, vsep = 2
    chain_start_loc = nil
    cbn_entry.chunks.each_with_index do |chunk, i|
      vsep.times{sink.newline} unless i.zero?
      if chunk.divert and chunk.initial then
        raise 'assertion failed' if chain_start_loc
        chain_start_loc = sink.location_ahead
      end
      << Tangle [[chunk]] to [[sink]] >>
      if chunk.divert and chunk.final then
        raise 'assertion failed' unless chain_start_loc
        (chunk.divert.chain_tangle_locs ||= []).push \
            OpenStruct.new(
                from: chain_start_loc,
                to: sink.location_behind)
        chain_start_loc = nil
      end
    end
    return
  end


In addition to expanding the chunk's content to [[sink]], we'll
also record its location in the output file, as kept track by
[[Tangling_Sink]].

<< Tangle [[chunk]] to [[sink]] >>:
  start_location = sink.location_ahead
  chunk.content.each do |node|
    case node.type
    when :verbatim then
      sink.write node.data
    when :newline then
      sink.newline
    when :use then
      tangle_transclusion node, sink, trace, chunk
    else raise 'data structure error'
    end
  end
  end_location = sink.location_behind

  # Both endpoints are inclusive.
  (chunk.tangle_locs ||= []).push OpenStruct.new(
    from: start_location,
    to: end_location)


For circular or dangling references, we'll write the raw
transclusion directive, as it appeared in the fabric, to output.
It's possible that we mistakenly parsed something that was not
intended as a reference, and while this should be fixed by
appropriate escaping (or, well, dividing the bogus reference
onto multiple code lines), this non-destructive approach is
probably optimal as workarounds go.

. [[tangle_transclusion]]
. "circular reference" (warning)
. "dangling reference" (warning)

<< in [[Integrator]] >>:
  def tangle_transclusion node, sink, trace, referrer
    name = node.name
    if trace.include? name then
      warn node.loc, "circular reference"
      sink.write node.raw
    else
      cbn_entry = @output.chunks_by_name[name]
      if cbn_entry.nil? or cbn_entry.chunks.empty? then
        warn node.loc, "dangling reference"
        sink.write node.raw
      else
        << Cross-reference the transclusion >>
        << Recurse and transclude >>
      end
    end
    return
  end


<< Cross-reference the transclusion >>:
  (cbn_entry.transcluders ||= []).push(
      OpenStruct.new(
        name: referrer.name,
        section_number: referrer.section_number,
        ))


<< Recurse and transclude >>:
  trace.add name
  if node.postprocess then
    # redirect the tangler
    outer_sink = sink
    inner_sport = StringIO.new
    sink = Fabricator::Tangling_Sink.new '(pipe)',
        inner_sport
  end
  sink.pin_indent node.clearindent ? 0 : nil do
    tangle_chunks cbn_entry, sink, trace,
        node.vertical_separation == '.dense' ? 1 : 2
  end
  if node.postprocess then
    # revert the redirect and apply the filter
    sink.newline
    filter_output =
        Fabricator::POSTPROCESSES[node.postprocess].
        call(inner_sport.string)
    sink = outer_sink
    sink.pin_indent node.clearindent ? 0 : nil do
      sink.write_long filter_output
    end
  end
  trace.delete name


<< in [[Fabricator]] >>:
  POSTPROCESSES = {
    '|scss->css' => proc do |input|
      require 'sass'
      Sass::Engine.new(input,
          syntax: :scss,
          load_paths: [],
          filename: '(pipe)').render
    end,

    '|sass->css' => proc do |input|
      require 'sass'
      Sass::Engine.new(input,
          syntax: :sass,
          load_paths: [],
          filename: '(pipe)').render
    end,

    '|cs->js' => proc do |input|
      require 'coffee-script'
      CoffeeScript.compile input
    end,
  }


* Tangle all the files.

The high-level tangling interface, [[Integrator#tangle_roots]],
sets up the [[tangles]] branch in the fabric.  (For idempotency,
it does nothing if it already exists.  This is mainly useful
because it calls [[tangle_chunks]] which has the side effect of
inserting cross-reference information into the fabric.)

. [[tangle_roots]]

<< in [[Integrator]] >>:
  def tangle_roots
    return if @output.tangles
    @output.tangles = {}
    @output.roots.each do |name|
      sport = StringIO.new
      sink = Fabricator::Tangling_Sink.new name, sport
      cbn_entry = @output.chunks_by_name[name]
      # We can assume that [[cbn_entry]] is not [[nil]], for
      # otherwise there wouldn't be a [[roots]] entry.
      tangle_chunks cbn_entry, sink, Set.new([name])
      sink.newline
      @output.tangles[name] = OpenStruct.new(
        filename: name,
        root_type: cbn_entry.root_type,
        content: sport.string,
        line_count: sink.line_count,
        nonblank_line_count: sink.nonblank_line_count,
        longest_line_length: sink.longest_line_length,
      )
    end
    return
  end


Finally, at the command line interface level, we'll just need to
call [[tangle_roots]] and write the results into files.  The
latter is done through the [[writeout_plan]] abstraction layer.

<< Tangle all roots >>:
  integrator.tangle_roots

. [[plan_to_write_out]]

<< Other methods >>:
  # Take a [[results]] record from tangling and construct a
  # matching [[proc]] to be stored in the [[writeout_plan]].
  def plan_to_write_out results
    return proc do |output_filename|
      File.write output_filename, results.content
      puts "Tangled #{results.filename},"
      if results.line_count != 1 then
        print "  #{results.line_count} lines"
      else
        print "  #{results.line_count} line"
      end
      puts " (#{results.nonblank_line_count} non-blank),"
      if results.longest_line_length != 1 then
        puts "  longest #{results.longest_line_length} chars."
      else
        puts "  longest #{results.longest_line_length} char."
      end
      << Script root?  Make executable >>
    end
  end


<< Script root?  Make executable >>:
  if results.root_type == '.script' and
      !Fabricator::WINDOWS_HOSTED_P then
    stat = File.stat output_filename
    m = stat.mode
    uc = ""
    [(m |= 0o100), (uc << "u")] if m & 0o400 != 0
    [(m |= 0o010), (uc << "g")] if m & 0o040 != 0
    [(m |= 0o001), (uc << "o")] if m & 0o004 != 0
    File.chmod m, output_filename
    puts "Set %s+x on %s, resulting in %03o" % [
      uc,
      output_filename,
      m & 0o777,
    ]
  end

<< in [[Fabricator]] >>:
  WINDOWS_HOSTED_P =
      (RbConfig::CONFIG['host_os'] =~ /mswin|mingw|cygwin/)


=== The tangling sink.

* The tangling sink.

The tangling sink serves as a back-end to the tangling loop,
taking care of indentation, right-stripping the generated lines,
and keeping track of the output location so as to permit
cross-referencing chunks with where they appear in the generated
files.

. [[Tangling_Sink]]

<< in [[Fabricator]] >>:
  class Tangling_Sink
    def initialize filename, port
      super()
      @filename = filename
      @port = port
      @lineno = 1
      @line = ''
      @indent = 0
      << Initialise statistical trackers >>
      return
    end

    << in [[Tangling_Sink]] >>
  end

<< in [[Tangling_Sink]] >>:


* Simple output.

. [[write]] (method of [[Tangling_Sink]])

  def write s
    @line << s
    return
  end


. [[newline]] (method of [[Tangling_Sink]])

  def newline
    @line.rstrip!
    @port.puts @line
    @lineno += 1
    << Count [[@line]] for statistics >>
    @line = ' ' * @indent
    return
  end


We'll use Ruby's block idiom for indentation.  By default,
[[pin_indent]] will retain the current column as the beginning
column for lines beginning during the thunk passed to it.  The
amount of indentation can be overridden by passing it to
[[pin_indent]] as a parameter.  (The parameter of [[nil]] can be
used to explicitly request the implicit behaviour.)  Such an
override is used to implement the [[.clearindent]] directive.

. [[pin_indent]]

  def pin_indent level = nil
    previous_indent = @indent
    begin
      @indent = level || @line.length
      yield
    ensure
      @indent = previous_indent
    end
    return
  end


A filter's output is written into a sink as a long multiline
string.  Note that we'll ignore trailing linebreaks in such a
string.

. [[write_long]] (method of [[Tangling_Sink]])

  def write_long s
    s.split(/\n/).each_with_index do |line, i|
      newline unless i.zero?
      write line
    end
    return
  end


* Location tracking.

. [[location_ahead]] (method of [[Tangling_Sink]])

  def location_ahead
    return OpenStruct.new(
      filename: @filename,
      line: @lineno,
      column: @line.length + 1)
  end


. [[location_behind]] (method of [[Tangling_Sink]])

  def location_behind
    return OpenStruct.new(
      filename: @filename,
      line: @lineno,
      column: @line.length)
  end


* And finally, statistics.

The number of output lines is easily calculated from the line
number tracker.

. [[line_count]] (method of [[Tangling_Sink]])

  def line_count
    return @lineno - 1
  end


The number of processed sections does not even need any
calculation.

<< in [[Integrator]] >>:
  attr_reader :section_count


In order to count non-blank lines, we need a separate counter.

<< Initialise statistical trackers >>:
  @nonblank_line_count = 0

<< in [[Tangling_Sink]] >>:
  attr_reader :nonblank_line_count

<< Count [[@line]] for statistics >>:
  @nonblank_line_count += 1 unless @line.empty?


We also want to find out the generated file's width.

<< Initialise statistical trackers >>:
  @longest_line_length = 0

<< in [[Tangling_Sink]] >>:
  attr_reader :longest_line_length

<< Count [[@line]] for statistics >>:
  @longest_line_length = @line.length \
      if @line.length > @longest_line_length

== Fabric loader's façade

For user's convenience, we'll encapsulate the parsing,
integration, and tangling of a fabric into a single procedure.

. [[load_fabric]]

<< Other methods >>:
  def load_fabric input, chunk_size_limit: 24
    << Parse fabric from [[input]] >>
    << Tangle all roots >>
    return integrator.output
  end

== Weaving

=== Coloured text

* Coloured text.

This output mode is convenient for use in a modern (x)terminal.

<< Weave [[fabric]] (ctxt) >>:
  open filename, 'w' do |port|
    symbolism = $cmdline.symbolism.dup
    symbolism.chunk_name_delim ||=
        if $cmdline.pseudographics ==
            Fabricator::ASCII_PSEUDOGRAPHICS then
          "<\<" .. ">>"
        else
          Fabricator.default_symbolism.chunk_name_delim
        end

    Fabricator.weave_ctxt fabric, port,
        width: $cmdline.output_width,
        symbolism: symbolism,
        pseudographics: $cmdline.pseudographics
  end
  puts "Weaved #{filename}"


. [[weave_ctxt]]

<< Other methods >>:
  def weave_ctxt fabric, port,
      width: 80,
      symbolism: default_symbolism,
      pseudographics: Fabricator::UNICODE_PSEUDOGRAPHICS
    wr = Fabricator::Text_Wrapper.new port,
        width: width,
        pseudographics: pseudographics
    << Weave fabric's warnings (ctxt) >>
    << Weave presentation (ctxt) >>
    unless fabric.index.empty? then
      << Weave index (ctxt) >>
    end
    return
  end

<< Weave fabric's warnings (ctxt) >>:
  unless fabric.warnings.empty? then
    wr.styled :section_title do
      wr.add_plain 'Warnings'
    end
    wr.linebreak
    wr.linebreak
    weave_ctxt_warning_list fabric.warnings, wr
    wr.linebreak
  end


Since warning lists can be output not only in the beginning of
the woven fabric but also inline, we'll implement this as a
procedure.

We'll want to be able to pass any random node's [[.warnings]] to
[[weave_ctxt_warning_list]] even if there aren't any warnings.
To that end, we'll first pass the [[list]] parameter through
[[#to_a]], which is a no-op for proper arrays but maps [[nil]]
to an empty list.

. [[weave_ctxt_warning_list]]

<< Other methods >>:
  def weave_ctxt_warning_list list, wr, inline: false,
      indent: true
    list.to_a.each do |warning|
      wr.styled inline ? :inline_warning : :null do
        wr.add_plain (indent ? '  ' : '') + '!!! ' if inline
        wr.add_plain format_location(warning.loc)
        wr.add_plain ':'
        wr.add_space
        wr.hang do
          warning.message.split(/(\s+)/).
              each_with_index do |part, i|
            if i.even? then
              wr.add_plain part
            else
              wr.add_space part
            end
          end
        end
      end
      wr.linebreak
    end
    return
  end


<< Weave presentation (ctxt) >>:
  toc_generated = false
  fabric.presentation.each do |element|
    case element.type
    when OL_TITLE then
      << Weave the title (ctxt) >>
    when OL_SECTION then
      << Weave the section (ctxt) >>
    else raise 'data structure error'
    end
  end


<< Weave the section (ctxt) >>:
  # [[element.elements]] can be empty if a section
  # contains index anchor(s) but no content.  This is a
  # pathological case, to be sure, but it can happen, so
  # we'll need to check.
  rubricated = !element.elements.empty? &&
      element.elements[0].type == OL_RUBRIC
  # If we're encountering the first rubric/title, output
  # the table of contents.
  if rubricated and !toc_generated then
    weave_ctxt_toc fabric.toc, wr,
        symbolism: symbolism
    toc_generated = true
  end

  << Weave the section's lead and set [[start_index]] (ctxt) >>

  << Weave the section's body from [[start_index]] on (ctxt) >>

  << Weave the section's top-level warnings (ctxt) >>


Weaving a section is a bit tricky, for we want to pretend that
both the section number, which is a field of an [[OL_SECTION]]
node, and the rubric (if any), which is optionally the first
child of it, comprise the section's title.  Furthermore,
following Knuth's practice, we'll want both to precede the first
regular paragraph, if any, without a separating paragraph break.

If the section has a rubric, we'll paint both the section number
and the rubric red (style [[:rubric]])  If there's no rubric,
the section number will be just bold ([[:section_number]], to be
precise).  This distinction corresponds to the Knuth's original
(C)WEB's practice of distinguishing 'starred sections' from
plain ones.

<< Weave the section's lead and set [[start_index]] (ctxt) >>:
  start_index = 0 # index of the first non-special child
  << Output section number and, possibly, the rubric (ctxt) >>

  # If the rubric or the section sign is followed by a
  # paragraph, a chunk header, or a divert, we'll output
  # it in the same paragraph.
  starter = element.elements[start_index]
  if starter then
    case starter.type
    when OL_PARAGRAPH, OL_DIVERT, OL_CHUNK then
      wr.add_space
      weave_ctxt_section_part starter, fabric, wr,
          symbolism: symbolism
      start_index += 1
    else
      wr.linebreak
    end
  end

  # Finally, the blank line that separates the special
  # paragraph from the section's body, if any.
  wr.linebreak

<< Output section number and, possibly, the rubric (ctxt) >>:
  if rubricated then
    start_index += 1
    wr.styled :rubric do
      wr.add_plain "%s%i." % [
        symbolism.section_prefix,
        element.section_number]
      wr.add_space
      wr.add_nodes element.elements.first.content,
          symbolism: symbolism
    end
  else
    wr.styled :section_number do
      wr.add_plain "%s%i." % [
        symbolism.section_prefix,
        element.section_number]
    end
  end

<< Weave the section's body from [[start_index]] on (ctxt) >>:
  element.elements[start_index .. -1].each do |child|
    weave_ctxt_section_part child, fabric, wr,
        symbolism: symbolism
    wr.linebreak
  end

. [[weave_ctxt_section_part]]

<< Other methods >>:
  def weave_ctxt_section_part element, fabric, wr,
      symbolism: default_symbolism
    case element.type
    << [[weave_ctxt_section_part]] rules >>
    else
      raise 'data structure error'
    end
    return
  end


<< [[weave_ctxt_section_part]] rules >>:

  when OL_PARAGRAPH then
    wr.add_nodes element.content, symbolism: symbolism
    wr.linebreak


  when OL_DIVERT, OL_CHUNK, OL_DIVERTED_CHUNK then
    if element.type & OLF_HAS_HEADER != 0 then
      weave_ctxt_chunk_header element, wr,
          symbolism: symbolism
      weave_ctxt_warning_list element.warnings, wr,
          inline: true
    end
    if element.type & OLF_HAS_CODE != 0 then
      << Weave the chunk's lines (ctxt) >>
      << ? Output the chain's finality marker >>
      weave_ctxt_warning_list element.warnings, wr,
          inline: true
      if element.final then
        wr.styled :chunk_xref do
          wr.add_nodes xref_chain(element, fabric,
                  symbolism: symbolism),
              symbolism: symbolism
        end
        wr.linebreak
      end
    end


  when OL_LIST then
    _weave_ctxt_list element.items, wr,
        symbolism: symbolism


  when OL_BLOCK then
    weave_ctxt_block element, wr


<< Weave the section's top-level warnings (ctxt) >>:
  unless (element.warnings || []).empty? then
    weave_ctxt_warning_list element.warnings, wr,
        inline: true, indent: false
    wr.linebreak
  end


* Weaving code elements.

This method is good for both chunks with headers and diverts,
which in its regard, are just chunk headers.

<< Other methods >>:

. [[weave_ctxt_chunk_header]]

  def weave_ctxt_chunk_header element, wr,
      symbolism: default_symbolism
    wr.styled :chunk_header do
      wr.add_plain symbolism.chunk_name_delim.begin
      if element.root_type then
        wr.styled :root_type do
          wr.add_plain element.root_type
        end
        wr.add_space
      end
      wr.add_nodes Fabricator.parse_markup(element.name,
              Fabricator::MF::LINK),
          symbolism: symbolism
      wr.add_plain symbolism.chunk_name_delim.end
      wr.add_plain ":"
    end
    wr.linebreak
    return
  end


. [[weave_ctxt_block]]

  def weave_ctxt_block element, wr
    element.lines.each do |line|
      wr.styled :block_frame do
        wr.add_pseudographics :block_margin
      end
      wr.styled :monospace do
        wr.add_plain line
      end
      wr.linebreak
    end
    return
  end


<< Weave the chunk's lines (ctxt) >>:
  wr.styled :chunk_frame do
    wr.add_pseudographics element.initial ?
      :initial_chunk_margin :
      :chunk_margin
  end
  wr.styled :monospace do
    element.content.each do |node|
      case node.type
      when :verbatim then
        wr.add_plain node.data
      when :newline then
        wr.linebreak
        wr.styled :chunk_frame do
          wr.add_pseudographics :chunk_margin
        end
      when :use then
        weave_ctxt_use node, wr,
            symbolism: symbolism
      else raise 'data structure error'
      end
    end
  end
  wr.linebreak


. [[weave_ctxt_use]]

<< Other methods >>:
  def weave_ctxt_use node, wr,
      symbolism: default_symbolism
    wr.styled :use do
      wr.add_plain symbolism.chunk_name_delim.begin
      if node.clearindent then
        wr.add_plain ".clearindent "
      end
      wr.add_nodes Fabricator.parse_markup(node.name,
              Fabricator::MF::LINK),
          symbolism: symbolism
      if node.vertical_separation then
        wr.add_plain " " + node.vertical_separation
      end
      if node.postprocess then
        wr.add_plain " " + node.postprocess
      end
      wr.add_plain symbolism.chunk_name_delim.end
    end
    return
  end


<< ? Output the chain's finality marker >>:
  if element.final then
    wr.styled :chunk_frame do
      wr.add_pseudographics :final_chunk_marker
    end
    wr.linebreak
  end


. [[xref_chain]] (function)

<< Other methods >>:
  # Given a chunk, prepare its transclusion summary as a list of
  # markup nodes.  Should only be used on chunks that are the
  # last in a chunk chain (i.e., that have [[final]] set).
  def xref_chain element, fabric,
      dash: "-", # used to indicate ranges
      symbolism: default_symbolism,
      link_sections: false
    xref = markup
    if element.initial then
      xref.words "This chunk is "
    else
      xref.words "These chunks are "
    end
    << Summarise chunk's referrers into [[xref]] >>
    xref.words " and "
    << List chunk's tangled locations into [[xref]] >>
    return xref
  end

<< Summarise chunk's referrers into [[xref]] >>:
  cbn_entry = fabric.chunks_by_name[element.name]
  transcluders = cbn_entry.transcluders
  if transcluders then
    xref.words "transcluded by "
    xref.push *commatise_oxfordly(
        transcluders.map{|ref| markup.
            node(MU_MENTION_CHUNK, name: ref.name).
            space.
            plain("(").
            node(MU_LINK,
              content: markup.
                  plain(symbolism.section_prefix +
                      ref.section_number.to_s),
              target: "#S.#{ref.section_number}").
            plain(")")
        })
  else
    if cbn_entry.root_type then
      xref.words "solely a transclusion root"
    else
      xref.words "never transcluded"
    end
  end

<< List chunk's tangled locations into [[xref]] >>:
  tlocs = element.divert ?
      element.divert.chain_tangle_locs :
      element.tangle_locs
  if tlocs then
    xref.
        words("tangled to ").
        push(*commatise_oxfordly(
        tlocs.map{|range| markup.
            plain(format_location_range(range, dash: dash))
        })).
        plain(".")
  else
    xref.words "never tangled."
  end


This contraption generates lists with Oxford/Harvard-style
commas.  The input is a list of lists of markup nodes.  The
output is a single list (to be specific, a
[[Markup_Constructor]], which inherits from [[Array]]) of markup
nodes, with appropriate joiners interspersed.

. [[commatise_oxfordly]]

<< Other methods >>:
  def commatise_oxfordly items
    result = markup
    items.each_with_index do |item, i|
      unless i.zero? then
        unless items.length == 2 then
          result.plain ','
        end
        result.space
        if i == items.length - 1 then
          result.plain 'and'
          result.space
        end
      end
      result.push *item
    end
    return result
  end


* Weaving other narrative elements.

<< Weave the title (ctxt) >>:
  if !toc_generated then
    weave_ctxt_toc fabric.toc, wr,
        symbolism: symbolism
    toc_generated = true
  end
  wr.styled :section_title do
    wr.add_plain "#{element.number}."
    wr.add_space
    wr.hang do
      wr.add_nodes element.content, symbolism: symbolism
    end
  end
  wr.linebreak
  wr.linebreak


<< Other methods >>:

. [[_weave_ctxt_list]]

  def _weave_ctxt_list items, wr,
      symbolism: default_symbolism
    items.each do |item|
      wr.add_pseudographics :bullet
      wr.add_plain " "
      wr.hang do
        wr.add_nodes item.content, symbolism: symbolism
      end
      wr.linebreak
      unless (item.warnings || []).empty? then
        wr.hang do
          weave_ctxt_warning_list item.warnings, wr,
              inline: true
        end
      end
      if item.sublist then
        wr.add_plain "  "
        wr.hang do
          _weave_ctxt_list item.sublist.items, wr,
              symbolism: symbolism
        end
      end
    end
    return
  end


. [[weave_ctxt_toc]]

  def weave_ctxt_toc toc, wr,
      symbolism: default_symbolism
    if toc.length >= 2 then
      wr.styled :section_title do
        wr.add_plain 'Contents'
      end
      wr.linebreak; wr.linebreak
      rubric_level = 0
      toc.each do |entry|
        << Weave the TOC entry (ctxt) >>
      end
      wr.linebreak
    end
    return
  end


<< Weave the TOC entry (ctxt) >>:
  case entry.type
  when OL_TITLE then
    rubric_level = entry.level - 1 + 1
    wr.add_plain '  ' * (entry.level - 1)
    wr.add_plain entry.number + '.'
    wr.add_space
    wr.hang do
      wr.add_nodes entry.content, symbolism: symbolism
    end

  when OL_RUBRIC then
    wr.add_plain '  ' * rubric_level
    wr.add_plain '%s%i.' % [
      symbolism.section_prefix,
      entry.section_number]
    wr.add_space
    wr.hang do
      wr.add_nodes entry.content, symbolism: symbolism
    end

  else
    raise 'assertion failed'
  end
  wr.linebreak


* Weaving the index.

<< Weave index (ctxt) >>:
  wr.styled :section_title do
    wr.add_plain 'Index'
  end
  wr.linebreak; wr.linebreak
  index = fabric.index
  index.keys.sort do |a, b|
    index[a].sort_key <=> index[b].sort_key
  end.each do |keyword|
    record = index[keyword]
    << Weave index record (ctxt) >>
  end


<< Weave index record (ctxt) >>:
  wr.add_nodes record.canonical_representation
  wr.hang 2 do
    record.refs.each_with_index do |(secno, reftype), i|
      wr.add_plain ',' unless i.zero?
      wr.add_space
      formatted_reference = _format_ctxt_index_ref secno,
          symbolism: symbolism
      << Weave index reference (ctxt) >>
    end
  end
  wr.linebreak

<< Weave index reference (ctxt) >>:
  case reftype
  when :manual then
    wr.add_plain formatted_reference

  when :definition then
    wr.styled :underscore do
      wr.add_plain formatted_reference
    end

  when :transclusion then
    wr.styled :italic do
      wr.add_plain formatted_reference
    end

  else
    raise 'assertion failed'
  end


. [[_format_ctxt_index_ref]]

<< Other methods >>:
  def _format_ctxt_index_ref target,
      symbolism: Fabricator.default_symbolism
    return case target
      when Integer then
        symbolism.section_prefix + target.to_s
      when Range then
        symbolism.section_prefix + target.begin.to_s +
            "-" +
            symbolism.section_prefix + target.end.to_s
      else
        raise 'type mismatch'
    end
  end


* The text wrapper.

We'll word-wrap the narrative (but not code) to a specified
output width using [[Text_Wrapper]].  It also accounts for the
escape sequences for colours, mainly by considering that their
width, for word-wrapping purposes, is zero.

. [[Text_Wrapper]]

<< in [[Fabricator]] >>:
  class Text_Wrapper
    def initialize port = $stdout,
        width: 80,
        pseudographics: UNICODE_PSEUDOGRAPHICS,
        palette: DEFAULT_PALETTE
      super()
      @port = port
      @width = width
      @pseudographics = pseudographics
      @palette = palette
      @hangindent = 0
      @curpos = 0
      @curspace = nil
      @curword = OpenStruct.new(
        prepared_output: '',
        width: 0)
      @curmode = @palette.null
      return
    end

    << in [[Text_Wrapper]] >>
  end


<< in [[Text_Wrapper]] >>:

Process a series of 'word' characters.  Note that these do not
have to comprise a whole word; a word can be fed into the
[[Text_Wrapper]] using multiple consecutive [[add_plain]] calls.
All word characters, even whitespaces among them, are considered
nonbreakable.

. [[add_plain]] (method of [[Text_Wrapper]])

  def add_plain data
    if @curspace and @curpos + data.length > @width then
      # the space becomes a linebreak
      @port.puts @palette.null
      @port.print ' ' * @hangindent + @curmode
      @curspace = nil
      @curpos = @hangindent + @curword.width
    end
    @curword.prepared_output << data
    @curpos += data.length
    return
  end


Process a space character (or several, or zero).  This sets up a
permitted line break point.

. [[add_space]] (method of [[Text_Wrapper]])

  def add_space data = ' '
    @port.print @curspace.prepared_output if @curspace
    @port.print @curword.prepared_output
    @curspace = OpenStruct.new(
      prepared_output: data,
      width: data.length)
    @curword = OpenStruct.new(
      prepared_output: '',
      width: 0)
    @curpos += data.length
    return
  end


Explicit linebreak.

. [[linebreak]] (method of [[Text_Wrapper]])

  def linebreak
    @port.print @curspace.prepared_output if @curspace
    @port.print @curword.prepared_output
    @port.puts @palette.null
    @port.print ' ' * @hangindent + @curmode
    @curspace = nil
    @curword = OpenStruct.new(
      prepared_output: '',
      width: 0)
    @curpos = @hangindent
    return
  end


Process a node, as generated by [[parse_markup]].

. [[add_node]] (method of [[Text_Wrapper]])

  def add_node node,
      symbolism: Fabricator.default_symbolism
    case node.type
    when MU_PLAIN then
      add_plain node.data
    when MU_SPACE then
      add_space node.data || ' '
    when MU_NBSP then
      add_plain ' '
    when MU_MONOSPACE, MU_BOLD, MU_ITALIC, MU_UNDERSCORE then
      # FIXME: this table should be a constant
      styled({
        MU_MONOSPACE => :monospace,
        MU_BOLD => :bold,
        MU_ITALIC => :italic,
        MU_UNDERSCORE => :underscore,
      }[node.type]) do
        add_nodes node.content, symbolism: symbolism
      end
    when MU_MENTION_CHUNK then
      add_plain symbolism.chunk_name_delim.begin
      add_nodes Fabricator.parse_markup(node.name,
              Fabricator::MF::LINK),
          symbolism: symbolism
      add_plain symbolism.chunk_name_delim.end
    when MU_LINK then
      if node.implicit_face then
        styled :link do
          add_plain '<'
          add_nodes node.content, symbolism: symbolism
          add_plain '>'
        end
      else
        add_plain '<'
        add_nodes node.content, symbolism: symbolism
        unless node.implicit_face then
          add_space ' '
          styled :link do
            add_plain node.target
          end
        end
        add_plain '>'
      end
    else
      # Uh-oh, a bug: the parser generated a node of a type
      # unknown to the weaver.
      raise 'invalid node type'
    end
    return
  end


Process a whole list of nodes.

. [[add_nodes]] (method of [[Text_Wrapper]])

  def add_nodes nodes,
      symbolism: Fabricator.default_symbolism
    nodes.each do |node|
      add_node node, symbolism: symbolism
    end
    return
  end


. hanging indentation
. indentation, hanging

Hanging indentation.  Used, for example, in the table of content
and in lists.  The content is to be fed into the
[[Text_Wrapper]] by the block supplied by the caller.
Optionally, the column to be used can be set explicitly.

. [[hang]] (method of [[Text_Wrapper]])

  def hang column = nil
    # convert the preceding whitespace, if any, into 'hard'
    # space not subject to future wrapping
    if @curspace then
      @port.print @curspace.prepared_output
      @curspace = nil
    end

    prev_hangindent = @hangindent
    begin
      @hangindent = column || @curpos
      yield
    ensure
      @hangindent = prev_hangindent
    end
    return
  end


A region wrapped in an escape sequence.  The sequence is looked
up in [[@palette]], is treated as having zero width, and it gets
turned off (using the [[:null]] style) during linebreaks; see
[[add_plain]].  The region's content is to be fed into the
[[Text_Wrapper]] by the block supplied by the caller.

Note that [[styled]] calls can be nested, but only the innermost
style is restored after linebreaks.

. [[styled]] (method of [[Text_Wrapper]])

  def styled sequence_name
    sequence = @palette[sequence_name]
    raise 'unknown palette entry' unless sequence
    prev_mode = @curmode
    begin
      @curmode = sequence
      @curword.prepared_output << sequence
      yield
    ensure
      @curmode = prev_mode
      @curword.prepared_output << prev_mode
    end
    return
  end


* Pseudographics.

We'll mark code chunks with running vertical lines on the left,
with a turn at the head or tail to indicate whether this chunk
is initial or final in its chain.  This is best done using box
graphics, for which we'll use Unicode, but for archaic devices,
we'll also support plain ASCII box graphics.

<< in [[Fabricator]] >>:

. [[UNICODE_PSEUDOGRAPHICS]]

  UNICODE_PSEUDOGRAPHICS = OpenStruct.new(
    bullet: [0x2022].pack('U*'),
    initial_chunk_margin: [0x2500, 0x2510].pack('U*'),
    chunk_margin: [0x0020, 0x2502].pack('U*'),
    block_margin: "  ",
    final_chunk_marker:
        ([0x0020, 0x2514] + [0x2500] * 3).pack('U*'),
  )


. [[ASCII_PSEUDOGRAPHICS]]

  ASCII_PSEUDOGRAPHICS = OpenStruct.new(
    bullet: "-",
    initial_chunk_margin: "+ ",
    chunk_margin: "| ",
    block_margin: "  ",
    final_chunk_marker: "----",
  )


As implied before, the default is Unicode.

<< Initialise [[$cmdline]] >>:
  $cmdline.pseudographics = Fabricator::UNICODE_PSEUDOGRAPHICS


Client code can output the pseudographics by this method.

. [[add_pseudographics]] (method of [[Text_Wrapper]])

<< in [[Text_Wrapper]] >>:
  def add_pseudographics name
    seq = @pseudographics[name]
    raise 'unknown pseudographics item' unless seq
    add_plain seq
    return
  end


* Palette.

<< in [[Fabricator]] >>:
  DEFAULT_PALETTE = OpenStruct.new(
    monospace: "\e[38;5;71m",
    bold: "\e[1m",
    italic: "\e[3m",
    underscore: "\e[4m",
    root_type: "\e[4m",
    chunk_frame: "\e[38;5;59m",
    block_frame: "",
    chunk_xref: "\e[38;5;59;3m",
    section_title: "\e[1;48;5;17m",
        # unspecified intense on dark blue background
    rubric: "\e[31;1m",
    section_number: "\e[0;1m",
    chunk_header: "\e[0;33;1m",
    use: "\e[34;1m",
    null: "\e[0m",
    inline_warning: "\e[31m",
    link: "\e[38;5;32m",
  )


=== HTML

* Overview.

First, let's take care of the I/O.

<< Weave [[fabric]] (HTML) >>:
  open filename, 'w' do |port|
    port.set_encoding 'utf-8'

    symbolism = $cmdline.symbolism.dup
    symbolism.chunk_name_delim ||=
        Fabricator.default_symbolism.chunk_name_delim

    Fabricator.weave_html fabric, port,
        title: $cmdline.fabric_filename,
        symbolism: symbolism,
        link_css: $cmdline.link_css
  end
  puts "Weaved #{filename}"


We'll keep the global parameters of an HTML weaving process in
an instance of [[HTML_Weaving]].

. [[HTML_Weaving]]

<< in [[Fabricator]] >>:
  class HTML_Weaving
    def initialize fabric, port,
        title: nil,
        symbolism: Fabricator.default_symbolism,
        link_css: [],
        link_processor: nil
      super()
      @fabric = fabric
      @port = port
      @title = title || "(Untitled)"
      @symbolism = symbolism
      @link_css = link_css
      @link_processor = link_processor
      return()
    end

    << in [[HTML_Weaving]] >>
  end


The process is shepherded by [[weave_html]].

. [[weave_html]]

<< Other methods >>:
  def weave_html fabric, port,
      title: nil,
      symbolism: default_symbolism,
      link_css: [],
      link_processor: nil
    weaving = Fabricator::HTML_Weaving.new fabric, port,
        title: title,
        symbolism: symbolism,
        link_css: link_css,
        link_processor: link_processor
    weaving.html
    return
  end


The next issue is the basic HTML structure.  We'll follow HTML 5
conventions.

<< in [[HTML_Weaving]] >>:

. [[html]] (method of [[HTML_Weaving]])

  def html
    @port.puts '<!doctype html>'
    @port.puts '<html>'
    html_head
    @port.puts '<body>'
    @port.puts
    @port.puts "<h1>#{@title.to_xml}</h1>"
    << Weave fabric's warnings (HTML) >>
    html_presentation
    unless @fabric.index.empty? then
      html_index
    end
    @port.puts '</body>'
    @port.puts '</html>'
    return
  end


. [[html_head]] (method of [[HTML_Weaving]])

  def html_head
    @port.puts '<head>'
    @port.puts "<meta http-equiv='Content-type' " +
        "content='text/html; charset=utf-8' />"
    @port.puts "<title>#{@title.to_xml}</title>"
    if @link_css.empty? then
      @port.puts "<style type='text/css'>"
      @port.write File.read(
          File.join(Fabricator::RESOURCE_DIR, 'maui.css'))
      @port.puts "</style>"
    else
      @link_css.each do |link|
        @port.puts ("<link rel='stylesheet' " +
            "type='text/css' href='%s' />") % link.to_xml
      end
    end
    @port.puts '</head>'
    return
  end


. [[html_presentation]] (method of [[HTML_Weaving]])

  def html_presentation
    toc_generated = false
    @fabric.presentation.each do |element|
      case element.type
      when OL_TITLE then
        << Weave the title (HTML) >>
      when OL_SECTION then
        << Weave the section (HTML) >>
      else raise 'data structure error'
      end
      @port.puts
    end
    return
  end

<< Weave the title (HTML) >>:
  if !toc_generated then
    html_toc
    toc_generated = true
  end
  @port.print '<h%i' % (element.level + 1)
  @port.print " id='%s'" % "T.#{element.number}"
  @port.print '>'
  @port.print "#{element.number}. "
  htmlify element.content
  @port.puts '</h%i>' % (element.level + 1)

. [[.maui-section]] (CSS class)

<< Weave the section (HTML) >>:
  rubricated = !element.elements.empty? &&
      element.elements[0].type == OL_RUBRIC
  # If we're encountering the first rubric/title, output
  # the table of contents.
  if rubricated and !toc_generated then
    html_toc
    toc_generated = true
  end

  start_index = 0
  @port.puts "<section class='maui-section' id='%s'>" %
      "S.#{element.section_number}"
  @port.puts
  << Weave the section's lead (HTML) >>
  @port.puts
  element.elements[start_index .. -1].each do |child|
    html_section_part child
    @port.puts
  end
  << Weave the section's top-level warnings, if any (HTML) >>
  @port.puts "</section>"

<< Weave the section's lead (HTML) >>:
  @port.print "<p>"
  << Weave section's number and rubric (HTML) >>
  subelement = element.elements[start_index]
  warnings = nil
  if subelement then
    case subelement.type
      when OL_PARAGRAPH then
        @port.print " "
        htmlify subelement.content
        start_index += 1
      when OL_DIVERT then
        @port.print " "
        html_chunk_header subelement, 'maui-divert',
            tag: 'span'
        warnings = subelement.warnings
        start_index += 1
      # FIXME: also support chunks here
    end
  end
  @port.puts "</p>"
  if warnings then
    html_warning_list warnings, inline: true
  end

. [[.maui-rubric]] (CSS class)
. [[.maui-section-number]] (CSS class)

<< Weave section's number and rubric (HTML) >>:
  @port.print "<b class='%s'>" %
      (rubricated ? 'maui-rubric' :
          'maui-section-number')
  @port.print @symbolism.section_prefix
  @port.print element.section_number
  @port.print "."
  if rubricated then
    @port.print " "
    htmlify element.elements[start_index].content
    start_index += 1
  end
  @port.print "</b>"


. [[html_section_part]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def html_section_part element
    case element.type
    << [[html_section_part]] rules >>
    else
      raise 'data structure error'
    end
    return
  end


<< [[html_section_part]] rules >>:

  when OL_PARAGRAPH then
    @port.print "<p>"
    htmlify element.content
    @port.puts "</p>"


  when OL_LIST then
    html_list element.items


  when OL_DIVERT then
    html_chunk_header element, 'maui-divert'
    @port.puts
    html_warning_list element.warnings, inline: true


. [[.maui-chunk]] (CSS class)
. [[.maui-initial-chunk]] (CSS class)
. [[.maui-final-chunk]] (CSS class)
. [[.maui-chunk-header]] (CSS class)
. [[.maui-chunk-xref]] (CSS class)

  when OL_CHUNK, OL_DIVERTED_CHUNK then
    @port.print "<div class='maui-chunk"
    @port.print " maui-initial-chunk" if element.initial
    @port.print " maui-final-chunk" if element.final
    @port.print "'>"
    if element.type == OL_CHUNK then
      html_chunk_header element, 'maui-chunk-header'
      @port.puts
    end
    html_chunk_body element
    unless (element.warnings || []).empty? then
      html_warning_list element.warnings, inline: true
    end
    if element.final then
      @port.print "<div class='maui-chunk-xref'>"
      htmlify(
          Fabricator.xref_chain(element, @fabric,
              symbolism: @symbolism,
              dash: "\u2013",
              link_sections: true))
      @port.puts "</div>"
    end
    @port.puts "</div>"


. [[.maui-block]] (CSS class)

  when OL_BLOCK then
    @port.print "<pre class='maui-block'>"
    element.lines.each_with_index do |line, i|
      @port.puts unless i.zero?
      @port.print line.to_xml
    end
    @port.puts "</pre>"


As in the coloured text output, the table of content takes a
general form of a tree.  However, HTML permits a new feature we
can't offer in non-hyper text: we're going to make each entry
into a local link, either in the [[#T.foo]] form for titles or
[[#S.foo]] form for sections.

. [[html_toc]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def html_toc
    if @fabric.toc.length >= 2 then
      @port.puts "<h2>Contents</h2>"
      last_level = 0
      # What level should the rubrics in the current
      # (sub(sub))chapter appear at?
      rubric_level = 1
      @fabric.toc.each do |entry|
        if entry.type == OL_RUBRIC then
          level = rubric_level
        else
          level = entry.level
          rubric_level = entry.level + 1
        end
        << Generate [[ul]]/[[li]] tags to match [[level]] >>
        << Weave the TOC entry (HTML) >>
        last_level = level
      end
      @port.puts "</li></ul>" * last_level; @port.puts
    end
    return
  end

<< Generate [[ul]]/[[li]] tags to match [[level]] >>:
  if level > last_level then
    raise 'assertion failed' \
        unless level == last_level + 1
    @port.print "\n<ul><li>"
  elsif level == last_level then
    @port.print "</li>\n<li>"
  else
    @port.print "</li></ul>" * (last_level - level) +
        "\n<li>"
  end

<< Weave the TOC entry (HTML) >>:
  case entry.type
  when OL_TITLE then
    @port.print "#{entry.number}. "
    @port.print "<a href='#T.#{entry.number}'>"
    htmlify entry.content
    @port.print "</a>"
  when OL_RUBRIC then
    @port.print @symbolism.section_prefix
    @port.print entry.section_number
    @port.print ". "
    @port.print "<a href='#S.#{entry.section_number}'>"
    htmlify entry.content
    @port.print "</a>"
  else
    raise 'assertion failed'
  end

. [[html_list]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def html_list items
    @port.puts "<ul>"
    items.each do |item|
      @port.print "<li>"
      htmlify item.content
      if item.sublist then
        @port.puts
        html_list item.sublist.items
      end
      unless (item.warnings || []).empty? then
        @port.puts
        html_warning_list item.warnings, inline: true
      end
      @port.puts "</li>"
    end
    @port.puts "</ul>"
    return
  end


<< in [[HTML_Weaving]] >>:

. [[html_chunk_header]] (method of [[HTML_Weaving]])

  def html_chunk_header element, cls, tag: 'div'
    @port.print "<#{tag} class='%s'>" % cls.to_xml
    @port.print @symbolism.chunk_name_delim.begin
    if element.root_type then
      @port.print "<u>%s</u> " % element.root_type.to_xml
    end
    htmlify Fabricator.parse_markup(element.name,
        Fabricator::MF::LINK)
    @port.print @symbolism.chunk_name_delim.end + ":"
    @port.print "</#{tag}>"
    # Note that we won't output a trailing linebreak here.
    return
  end


. [[html_chunk_body]] (method of [[HTML_Weaving]])
. [[.maui-chunk-body]] (CSS class)

  def html_chunk_body element
    @port.print "<pre class='maui-chunk-body'>"
    element.content.each do |node|
      case node.type
      when :verbatim then
        @port.print node.data.to_xml
      when :newline then
        @port.puts
      when :use then
        << Weave the [[use]] node (HTML) >>
      else raise 'data structure error'
      end
    end
    @port.puts "</pre>"
    return
  end

. [[.maui-transclude]] (CSS class)

<< Weave the [[use]] node (HTML) >>:
  @port.print "<span class='maui-transclude'>"
  @port.print @symbolism.chunk_name_delim.begin
  if node.clearindent then
    @port.print ".clearindent "
  end
  htmlify(
      Fabricator.parse_markup(node.name,
          Fabricator::MF::LINK))
  if node.vertical_separation then
    @port.print " " + node.vertical_separation.to_xml
  end
  if node.postprocess then
    @port.print " " + node.postprocess.to_xml
  end
  @port.print @symbolism.chunk_name_delim.end
  @port.print "</span>"


* Displaying warnings in HTML.

<< Weave the section's top-level warnings, if any (HTML) >>:
  unless (element.warnings || []).empty? then
    html_warning_list element.warnings, inline: true
    @port.puts
  end

<< Weave fabric's warnings (HTML) >>:
  unless @fabric.warnings.empty? then
    @port.puts "<h2>Warnings</h2>"
    @port.puts
    html_warning_list @fabric.warnings
    @port.puts
  end

. [[html_warning_list]]
. [[.maui-warnings]] (CSS class)
. [[.maui-inline-warnings]] (CSS class)

<< in [[HTML_Weaving]] >>:
  def html_warning_list list, inline: false
    if list and !list.empty? then
      @port.print "<ul class='maui-warnings"
      @port.print " maui-inline-warnings" if inline
      @port.puts "'>"
      list.each do |warning|
        @port.print "<li"
        @port.print " id='W.#{warning.number}'" if inline
        @port.print ">"
        @port.print "!!! " if inline
        if !inline and warning.inline then
          @port.print "<a href='#W.%i'>" % warning.number
        end
        @port.print "<tt>%s</tt>" %
            Fabricator.format_location(warning.loc).to_xml
        @port.print ": " + warning.message
        @port.print "</a>" if !inline and warning.inline
        @port.puts "</li>"
      end
      @port.puts "</ul>"
    end
    return
  end


* Generating the index in HTML.

. [[html_index]] (method of [[HTML_Weaving]])
. [[#maui-index]] (CSS identifier)

<< in [[HTML_Weaving]] >>:

  def html_index
    @port.puts "<h2>Index</h2>"
    @port.puts
    @port.puts "<nav id='maui-index'>"
    @port.puts "<ul>"
    index = @fabric.index
    index.keys.sort do |a, b|
      index[a].sort_key <=> index[b].sort_key
    end.each do |keyword|
      record = index[keyword]
      @port.print "<li>"
      htmlify record.canonical_representation
      @port.print " "
      record.refs.each_with_index do |(secno, reftype), i|
        @port.print ',' unless i.zero?
        @port.print ' '
        html_index_reference secno, reftype
      end
      @port.puts "</li>"
    end
    @port.puts "</ul>"
    @port.puts "</nav>"
    return
  end


. [[.maui-index-manual]] (CSS class)
. [[.maui-index-definition]] (CSS class)
. [[.maui-index-transclusion]] (CSS class)

  def html_index_reference secno, reftype
    @port.print "<span class='maui-index-#{reftype}'>"
    case secno
      when Integer then
        @port.print "<a href='#S.#{secno}'>"
        @port.print @symbolism.section_prefix
        @port.print secno
        @port.print "</a>"
      when Range then
        # The hyperlink will reference only the very first
        # section in the range, but we'll mark the whole
        # range up as a link for cosmetic reasons.
        @port.print "<a href='#S.#{secno.begin}'>"
        @port.print @symbolism.section_prefix
        @port.print secno.begin
        @port.print "\u2013"
        @port.print @symbolism.section_prefix
        @port.print secno.end
        @port.print "</a>"
      else
        raise 'assertion failed'
    end
    @port.print "</span>"
    return
  end


. [[.maui-index-manual]] (CSS class)
. [[.maui-index-definition]] (CSS class)
. [[.maui-index-transclusion]] (CSS class)

<< Sass rules >>:
  // .maui-index-manual does not need any rules

  .maui-index-definition
    text-decoration: underline

  .maui-index-transclusion
    font-style: italic


* Conversion of a horizontal markup tree to HTML.

. [[htmlify]] (method of [[HTML_Weaving]])

<< in [[HTML_Weaving]] >>:
  def htmlify nodes
    nodes.each do |node|
      case node.type
      << [[case]] clauses of [[htmlify]] >>
      else
        raise 'invalid node type'
      end
    end
    return
  end


<< [[case]] clauses of [[htmlify]] >>:

  when MU_PLAIN then
    @port.print node.data.to_xml


  when MU_SPACE then
    @port.print((node.data || ' ').to_xml)


  when MU_NBSP then
    @port.print '&nbsp;'


  when MU_MONOSPACE, MU_BOLD, MU_ITALIC, MU_UNDERSCORE then
    html_tag = Fabricator::MARKUP2HTML[node.type]
    @port.print "<%s>" % html_tag
    htmlify node.content
    @port.print "</%s>" % html_tag


. [[.maui-chunk-mention]] (CSS class)

  when MU_MENTION_CHUNK then
    @port.print "<span class='maui-chunk-mention'>"
    @port.print @symbolism.chunk_name_delim.begin
    htmlify Fabricator.parse_markup(node.name,
        Fabricator::MF::LINK)
    @port.print @symbolism.chunk_name_delim.end
    @port.print "</span>"


  when MU_LINK then
    target = node.target
    if @link_processor then
      target, *classes = @link_processor.call target
    else
      classes = []
    end
    @port.print "<a href='#{target.to_xml}'"
    unless classes.empty? then
      @port.print " class='#{classes.join(' ').to_xml}'"
    end
    @port.print ">"
    htmlify node.content
    @port.print "</a>"


<< in [[Fabricator]] >>:
  MARKUP2HTML = { # node type tag => HTML tag
    MU_MONOSPACE => 'code',
    MU_BOLD => 'b',
    MU_ITALIC => 'i',
    MU_UNDERSCORE => 'u',
  }


* XML escaping.

<< Outer definitions >>:
  class ::String
    # Local enclosed variable for [[#to_xml]]
    char_entities = {
      '&' => '&amp;',
      '<' => '&lt;',
      '>' => '&gt;',
      '"' => '&quot;',
      "'" => '&apos;',
    }.freeze

    define_method :to_xml do ||
      return gsub(/[&<>'"]/){char_entities[$&]}
    end
  end


* The built-in stylesheet.

Our built-in stylesheet has been written in Sass.  Maui runs it
through the Sass translator to get plain CSS at tangling time.

<< .file res/maui.css >>:
  << res/maui.sass |sass->css >>


<< .file res/maui.sass >>:
  /* * * *   Fonts   * * * */
  << Sass [[@import]] clauses for Google fonts >>

  // * * * * Dimensions
  << Sass dimensions >>

  // * * * * Colours
  << Sass colours >>

  /* * * *   Rules   * * * */
  << Sass rules >>


Maui's HTML-woven output uses two font families: a 'plain text'
one for most of the narrative and a 'monospaced' one for actual
code.  We have chosen Roboto for the former and Cousine for the
latter.

<< Sass [[@import]] clauses for Google fonts >>:
  $fontsrc: "http://fonts.googleapis.com/css?family="
  $fontvariants: "400,400italic,700,700italic"
  @import url("#{$fontsrc}Roboto:#{$fontvariants}")
  @import url("#{$fontsrc}Cousine:#{$fontvariants}")

. [[.maui-transclude]] (CSS class)

<< Sass rules >>:
  body, .maui-transclude
    font-family: "Roboto", sans-serif

  pre, tt, code
    font-family: "Cousine", monospace


The main text for Maui's output will be black on white.

<< Sass colours >>:
  $main-foreground: black
  $main-background: white

<< Sass rules >>:
  body
    colour: $main-foreground
    background: $main-background


Furthermore, when monospaced text appears in narrative (as
contrary to code chunks), we'll dye it green for extra
highlighting.

<< Sass colours >>:
  $narrative-monospaced-colour: forestgreen

<< Sass rules >>:
  tt, code
    color: $narrative-monospaced-colour


Inline warnings we'll paint bright red for high visibility.
(Note that the class' name is in plural --- a single HTML
element can contain multiple warnings.)

<< Sass colours >>:
  $inline-warning-colour: red

. [[.maui-inline-warnings]] (CSS class)

<< Sass rules >>:
  .maui-inline-warnings
    color: $inline-warning-colour


The rules so far have a conflict.  What happens when a [[tt]]
element appears inside an inline warning?  Left alone, they
would become green.  However, in this context, we'll want them
red.

. [[.maui-warnings]] (CSS class)

<< Sass rules >>:
  .maui-warnings tt
    color: inherit


By medieval tradition, rubrics should be red.  We'll use a
slightly darker shade and go with what CSS calls [[crimson]]
instead of [[red]].

<< Sass colours >>:
  $rubric-colour: crimson

. [[.maui-rubric]] (CSS class)

<< Sass rules >>:
  .maui-rubric
    color: $rubric-colour


Maui outputs warnings in unordered lists, but we don't actually
want bullets in front of them.

. [[.maui-warnings]] (CSS class)

<< Sass rules >>:
  ul.maui-warnings
    padding-left: 0
    > li
      list-style: none


Let us now proceed to styling the code chunks themselves.
First, the rules:

<< Sass colours >>:
  $chunk-rule-colour: #cccccc

<< Sass dimensions >>:
  $chunk-indent: 20px
  $chunk-rule: 2px
  $chunk-rule-sep: 5px
  $final-chunk-rule-length: 40px

. [[.maui-chunk-body]] (CSS class)
. [[.maui-initial-chunk]] (CSS class)
. [[.maui-final-chunk]] (CSS class)

<< Sass rules >>:
  .maui-chunk-body
    margin-left: $chunk-indent
    border-left: $chunk-rule solid $chunk-rule-colour
    padding-left: $chunk-rule-sep

  .maui-initial-chunk>.maui-chunk-body:before
    content: ""
    display: block
    width: $chunk-indent + $chunk-rule
    border-top: solid $chunk-rule $chunk-rule-colour
    margin-left: - $chunk-indent - $chunk-rule - $chunk-rule-sep

  .maui-final-chunk>.maui-chunk-body:after
    content: ""
    display: block
    margin-left: - $chunk-rule - $chunk-rule-sep
    width: $final-chunk-rule-length
    border-bottom: solid $chunk-rule $chunk-rule-colour


A chunk's body shall have zero vertical margins; its containing
[[maui-chunk]] will take care of vertical separation.  This also
applies to the block of warnings inside a chunk.

<< Sass dimensions >>:
  $paragraph-sep: 16px

. [[.maui-chunk-body]] (CSS class)
. [[.maui-chunk]] (CSS class)
. [[.maui-warnings]] (CSS class)

<< Sass rules >>:

  .maui-chunk-body, .maui-chunk>.maui-warnings
    margin-top: 0
    margin-bottom: 0

  .maui-chunk
    margin-top: $paragraph-sep
    margin-bottom: $paragraph-sep


The cross-references following (final) chunks are smaller and in
italic for reduced obtrusivity, and they align with the chunk's
vertical rule but are deliberately slightly off from aligning
with the code inside the chunk.

. [[.maui-chunk-xref]] (CSS class)

  .maui-chunk-xref
    font-size: small
    font-style: italic
    margin-left: $chunk-indent + $chunk-rule


We'll apply the same left indentation to sample code blocks as
to chunks, except without the running vertical rule.

. [[.maui-block]] (CSS class)

  .maui-block
    margin-left: $chunk-indent + $chunk-rule + $chunk-rule-sep


Finally, this rule tells pre-HTML5 browsers that [[section]] is
[[div]]-like, not [[span]]-like:

<< Sass rules >>:
  /* Backwards compatibility with pre-HTML5 browsers */
  section
    display: block


=== Symbolism

Several of the symbols Maui uses in its weaved representation of
fabrics are customisable.  To that end, many weaving subroutines
accept, and pass on, [[OpenStruct]] instances with the preferred
symbols.  Here are the defaults.

. [[default_symbolism]]

<< Other methods >>:
  def default_symbolism
    return OpenStruct.new(
        section_prefix: "§",
        # Two endpoints are stored in a [[Range]].
        chunk_name_delim: "\u00AB" .. "\u00BB")
  end


== The skeletal composition of the library

. [[Fabricator]] (top-level module)

<< .file lib/mau/fabricator.rb >>:
  # encoding: UTF-8

  require 'ostruct'
  require 'rbconfig'
  require 'set'
  require 'stringio'

  << Outer definitions >>

  module Fabricator
    RESOURCE_DIR = File.expand_path '../../res',
        File.dirname(__FILE__)
    << in [[Fabricator]] >>
  end

  class << Fabricator
    include Fabricator
    << Other methods >>
  end


== The command line interface

<< .script bin/maui >>:
  #! /usr/bin/ruby -rubygems
  # encoding: UTF-8

  require 'getoptlong'
  require 'mau/fabricator'

  $0 = 'maui' # for [[GetoptLong]] error reporting
  << Parse command line >>

  fabric = open $cmdline.fabric_filename, 'r' do |port|
    Fabricator.load_fabric port,
        chunk_size_limit: $cmdline.chunk_size_limit
  end

  << Set up the [[writeout_plan]] >>

  Fabricator.show_warnings fabric

  << Execute the [[writeout_plan]] >>


<< Set up the [[writeout_plan]] >>:
  writeout_plan = {}
  << Plan to write out tangling results >>
  << Plan to write out specially generated files >>


<< Plan to write out tangling results >>:
  fabric.tangles.each_value do |results|
    writeout_plan[results.filename] =
        Fabricator.plan_to_write_out(results)
  end


<< Plan to write out specially generated files >>:
  [
    << Special out-writables >>
  ].each do |special|
    filename = File.basename($cmdline.fabric_filename).
        sub(/(\.fab)?$/i, special.suffix)
    if writeout_plan.has_key? filename then
      number = fabric.warnings.length + 1
      first_header = fabric.chunks_by_name[filename].
          headers.first
      warning = OpenStruct.new(
        loc: first_header.header_loc,
        message: "name clash with #{special.description}",
        number: number,
        inline: true,
      )
      fabric.warnings.push warning
      (first_header.warnings ||= []).push warning
      # For ordering purposes, we'll delete the old value before
      # adding the new one at the same key.
      writeout_plan.delete filename
    end
    writeout_plan[filename] = special.generator
  end


<< Special out-writables >>:

  OpenStruct.new(
    suffix: '.html',
    description: 'HTML weaving',
    generator: proc do |filename|
      << Weave [[fabric]] (HTML) >>
    end,
  ),


  OpenStruct.new(
    suffix: '.ctxt',
    description: 'ctxt weaving',
    generator: proc do |filename|
      << Weave [[fabric]] (ctxt) >>
    end,
  ),


<< Execute the [[writeout_plan]] >>:
  exit_code = 0
  (ARGV.empty? ? writeout_plan.keys : ARGV.uniq).
      each do |filename|
    if thunk = writeout_plan[filename] then
      path = filename.split '/'
      (0 .. path.length - 2).each do |i|
        dirname = path[0 .. i].join '/'
        begin
          Dir.mkdir dirname
          puts "Created directory #{dirname}"
        rescue Errno::EEXIST
        end
      end
      thunk.call filename
    else
      $stderr.puts "maui: #{filename}: unknown output file"
      exit_code = 1
    end
  end
  exit exit_code


== Rubygem metadata

<< .file maui.gemspec >>:
  # This file is tangled from [[maui.fab]].
  # Please do not edit directly.

  Gem::Specification.new do |s|
    s.name = 'maui'
    s.version = '<< VERSION >>'
    s.date = '2014-09-23'
    s.homepage = 'https://github.com/digwuren/maui'
    s.summary = 'A wiki-style literate programming engine'
    s.author = 'Andres Soolo'
    s.email = 'dig@mirky.net'
    s.files = File.read('Manifest.txt').split(/\n/)
    s.executables << 'maui'
    s.license = 'GPL-3'
    s.description = <<EOD
  Fabricator is a literate programming engine with wiki-like
  notation.  Mau is a PIM-oriented wiki engine built around
  Fabricator.  This gem contains Maui, the Mau Independent
  Fabricator, allowing Fabricator to be used via a command line
  interface or via the Ruby API without a need to employ a full
  installation of Mau.
  EOD
    s.has_rdoc = false
  end

<< .file Manifest.txt >>:
  GPL-3
  Makefile
  Manifest.txt
  README.fab
  README.html
  bin/maui
  lib/mau/fabricator.rb
  res/maui.css
  res/maui.sass
  maui.fab
  maui.gemspec


* The command line parser.

<< Parse command line >>:
  begin
    << Parse command line options >>
    << Parse command line arguments >>
  rescue GetoptLong::Error => e
    # no need to display; it has already been reported
    exit 1
  end

<< Parse command line options >>:
  $cmdline = OpenStruct.new
  << Initialise [[$cmdline]] .dense >>

  GetoptLong.new(
      << Option declarations .dense >>
      ).each do |opt, arg|
    case opt
    << Command line option handlers >>
    else
      raise 'assertion failed'
    end
  end


<< Initialise [[$cmdline]] >>:
  $cmdline.symbolism = OpenStruct.new(section_prefix: "§")


. [[--section-prefix]]

<< Option summary >>:
  --section-prefix=STRING
      Use this string rather than § as the section prefix.

<< Option declarations >>:
  ['--section-prefix', GetoptLong::REQUIRED_ARGUMENT],

<< Command line option handlers >>:
  when '--section-prefix' then
    $cmdline.symbolism.section_prefix = arg


. [[--chunk-name-delim]]

<< Option summary >>:
  --chunk-name-delim=BEFORE,AFTER
      Use these strings around chunks' names.

<< Option declarations >>:
  ['--chunk-name-delim', GetoptLong::REQUIRED_ARGUMENT],

<< Command line option handlers >>:
  when '--chunk-name-delim' then
    before, after = arg.split ',', 2
    unless after then
      $stderr.puts "maui: " +
          "--chunk-name-delim requires two strings"
      exit 1
    end
    $cmdline.symbolism.chunk_name_delim = before .. after


. [[--output-width]]

<< Option summary >>:
  --output-width=N
      Word-wrap the woven ctxt at this width.

<< Option declarations >>:
  ['--output-width', GetoptLong::REQUIRED_ARGUMENT],

<< Initialise [[$cmdline]] >>:
  $cmdline.output_width = 80

<< Command line option handlers >>:
  when '--output-width' then
    unless arg =~ /\A\d+\Z/ then
      $stderr.puts "maui: --output-width requires a number"
      exit 1
    end
    $cmdline.output_width = arg.to_i


Chunks longer than this many lines will be dubbed 'long' by a
warning.  If longer than twice this many lines, 'very long'.
Zero disables this check.

. [[--chunk-size-limit]]

<< Option summary >>:
  --chunk-size-limit=LINE-COUNT
      Consider chunks longer than this many lines warnably long.
      Chunks longer than twice this many lines will be
      considered warnably very long.

<< Option declarations >>:
  ['--chunk-size-limit', GetoptLong::REQUIRED_ARGUMENT],

<< Initialise [[$cmdline]] >>:
  $cmdline.chunk_size_limit = 24

<< Command line option handlers >>:
  when '--chunk-size-limit' then
    unless arg =~ /\A\d+\Z/ then
      $stderr.puts "maui: --chunk-size-limit " +
          "requires a number"
      exit 1
    end
    arg = arg.to_i
    arg = nil if arg <= 0
    $cmdline.chunk_size_limit = arg


For HTML output, the [[--link-css]] option permits the user to
specify one or more stylesheets that should be applied to the
result.

. [[--link-css]]

<< Option summary >>:
  --link-css=URL
      Specify a stylesheet to be applied to the woven HTML.
      Availability of the target CSS to the browser and the
      relativity of the link are user's responsibility.  If used
      multiple times, all these links will be used, and their
      order is preserved.

      Usage of this option suppresses including the default,
      built-in stylesheet in the output.

<< Option declarations >>:
  ['--link-css', GetoptLong::REQUIRED_ARGUMENT],

<< Initialise [[$cmdline]] >>:
  $cmdline.link_css = []

<< Command line option handlers >>:
  when '--link-css' then
    $cmdline.link_css.push arg


<< Parse command line arguments >>:
  if ARGV.empty? then
    $stderr.puts "maui: no fabric filename given"
    exit 1
  end
  $cmdline.fabric_filename = ARGV.shift


. [[--unicode-boxes]]

<< Command line option handlers >>:
  when '--unicode-boxes' then
    $cmdline.pseudographics =
        Fabricator::UNICODE_PSEUDOGRAPHICS

<< Option declarations >>:
  ['--unicode-boxes', GetoptLong::NO_ARGUMENT],


. [[--ascii-boxes]]

<< Command line option handlers >>:
  when '--ascii-boxes' then
    $cmdline.pseudographics = Fabricator::ASCII_PSEUDOGRAPHICS

<< Option declarations >>:
  ['--ascii-boxes', GetoptLong::NO_ARGUMENT],


Finally, the GNU Coding Standards recommend implementing
[[--help]] and [[--version]].

. [[--help]]

<< Option summary >>:
  --help
      Print this usage.

<< Option declarations >>:
  ['--help', GetoptLong::NO_ARGUMENT],

<< Command line option handlers >>:
  when '--help' then
    puts "<< .clearindent Usage help >>"
    puts
    exit 0


<< Usage help >>:
  Usage: maui [options] fabric-file

  Process the given Mau fabric, tangle its files and weave its
  narrative into both HTML and coloured text.

  << Option summary >>

  Report bugs to: <dig@mirky.net>


. [[--version]]

<< Option summary >>:
  --version
      Show version data.

<< Option declarations >>:
  ['--version', GetoptLong::NO_ARGUMENT],

<< Command line option handlers >>:
  when '--version' then
    puts "<< .clearindent [[--version]] output >>"
    puts
    exit 0

<< [[--version]] output >>:
  << IDENT >>
  Copyright (C) 2003-2014 Andres Soolo
  Copyright (C) 2013-2014 Knitten Development Ltd.

  Licensed under GPLv3+: GNU GPL version 3 or later
    <http://gnu.org/licenses/gpl.html>

  This is free software: you are free to change and
  redistribute it.

  There is NO WARRANTY, to the extent permitted by law.

